<!DOCTYPE html>
<html lang="">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Nodejs之EventLoop">




  <meta name="keywords" content="nodejs,">





  <link rel="alternate" href="/default" title="前端技术文档">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yoursite.com/2018/05/15/nodejs-event-loop/">


<meta name="description" content="初识EventLoopEventLoop是一个程序结构，用于等待、发送消息和事件。 事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。  从WebServer理解EventLoopNode JS构成的web服务器和传统的多线程服务器不一样，Node">
<meta name="keywords" content="nodejs">
<meta property="og:type" content="article">
<meta property="og:title" content="Nodejs之EventLoop">
<meta property="og:url" content="http://yoursite.com/2018/05/15/nodejs-event-loop/index.html">
<meta property="og:site_name" content="前端技术文档">
<meta property="og:description" content="初识EventLoopEventLoop是一个程序结构，用于等待、发送消息和事件。 事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。  从WebServer理解EventLoopNode JS构成的web服务器和传统的多线程服务器不一样，Node">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB36bfba2beaca697929ad575a619f5f88?method=download&shareKey=75c7e9f235e0adaf39668432e519b866">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBfd1cd7fffbabbcf4ed4a394c7cfa5b29?method=download&shareKey=aed35c468e885549ac91f2f0a0123c1d">
<meta property="og:updated_time" content="2018-10-31T11:09:21.743Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nodejs之EventLoop">
<meta name="twitter:description" content="初识EventLoopEventLoop是一个程序结构，用于等待、发送消息和事件。 事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。  从WebServer理解EventLoopNode JS构成的web服务器和传统的多线程服务器不一样，Node">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/WEB36bfba2beaca697929ad575a619f5f88?method=download&shareKey=75c7e9f235e0adaf39668432e519b866">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Nodejs之EventLoop - 前端技术文档 </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">前端技术文档</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Nodejs之EventLoop
        
      </h1>

      <time class="post-time">
          May 15 2018
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="初识EventLoop"><a href="#初识EventLoop" class="headerlink" title="初识EventLoop"></a>初识EventLoop</h3><p>EventLoop是一个程序结构，用于等待、发送消息和事件。</p>
<p>事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB36bfba2beaca697929ad575a619f5f88?method=download&amp;shareKey=75c7e9f235e0adaf39668432e519b866" alt="image"></p>
<h3 id="从WebServer理解EventLoop"><a href="#从WebServer理解EventLoop" class="headerlink" title="从WebServer理解EventLoop"></a>从WebServer理解EventLoop</h3><p>Node JS构成的web服务器和传统的多线程服务器不一样，Node JS只有一个进程处理请求和响应。</p>
<p>Node JS处理请求如下：</p>
<ol>
<li>client发送request到server</li>
<li>server将requst放入名为EventQueue的队列</li>
<li>EventLoop从EventQueue中取出request</li>
<li>如果request含有IO任务或者其他耗时，则从内部线程池中获取线程去处理该请求，一切处理完成后，将response发送回EventLoop</li>
<li>如果request中不含有耗时任务，则EventLoop会直接处理，将response发送给client。</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfd1cd7fffbabbcf4ed4a394c7cfa5b29?method=download&amp;shareKey=aed35c468e885549ac91f2f0a0123c1d" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class EventLoop &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if(Event Queue receives a JavaScript Function Call)&#123;</span><br><span class="line">            ClientRequest request = EventQueue.getClientRequest();</span><br><span class="line">            If(request requires BlokingIO or takes more computation time)</span><br><span class="line">                Assign request to Thread T1</span><br><span class="line">            Else</span><br><span class="line">                Process and Prepare response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>对于多并发无压力</li>
<li>不会随着请求的增多而迅速增大开销</li>
<li>使用的线程比较少，所以占用的资源也比较少</li>
</ul>
<h3 id="EventLoop-vs-Worker-Pool"><a href="#EventLoop-vs-Worker-Pool" class="headerlink" title="EventLoop vs Worker Pool"></a>EventLoop vs Worker Pool</h3><p>EventLoop 执行non-blocking的异步任务，一般为JavaScript的callback。</p>
<p>Worker Pool在libuv中实现，Worker Pool中执行“expensive”任务，包含操作系统没提供异步处理的任务，比如I/O，数据库访问等，还有部分比较消耗CPU的任务。</p>
<ul>
<li>I/O集中的任务<ul>
<li>DNS : dns.lookup(), dns.lookupService().</li>
<li>FileSystem</li>
</ul>
</li>
<li>CPU集中的任务<ul>
<li>Zlib</li>
<li>Crypto</li>
</ul>
</li>
</ul>
<h3 id="EventLoop各个阶段分析"><a href="#EventLoop各个阶段分析" class="headerlink" title="EventLoop各个阶段分析"></a>EventLoop各个阶段分析</h3><p>当Node启动的时候会初始化Event Loop，在初始化Event Loop的时候会执行一段传入进来的脚本，然后开始事件循环。</p>
<p>事件循环的大体顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<h4 id="理解要点："><a href="#理解要点：" class="headerlink" title="理解要点："></a>理解要点：</h4><ol>
<li>event loop 会分阶段执行，每个阶段都会有各自的FIFO队列</li>
<li>到达每个阶段后会一直执行，直到当前阶段队列为空，或者执行的callback达到了最大限度</li>
<li>timers阶段涉及到的有setTimeout和setInterval</li>
<li>I/O callback阶段执行除了close、timer、setImmediate相关回调的所有回调</li>
<li>poll会获取新的I/O事件并执行，当队列为空的时候，会检测timer队列，如果timer对了不为空，并且已经到执行时间，则会执行timer。node有可能阻塞在这个阶段。</li>
<li>check阶段执行setImmediate的回调</li>
<li>close阶段执行所有的关闭回调，如socket的关闭</li>
<li>process.nextTick比较特殊，在每个阶段的末尾执行。</li>
<li>官方建议使用setImediate代替process.nextTick。</li>
</ol>
<h4 id="timer阶段"><a href="#timer阶段" class="headerlink" title="timer阶段"></a>timer阶段</h4><p>timer会指定一个阈值，当达到这个阈值的时候，就会去执行对应的callback，然而实际执行的过程中，timer什么时候执行是由poll阶段控制的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation(callback) &#123;</span><br><span class="line">  // Assume this takes 95ms to complete</span><br><span class="line">  fs.readFile(&apos;/path/to/file&apos;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeoutScheduled = Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  const delay = Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// do someAsyncOperation which takes 95 ms to complete</span><br><span class="line">someAsyncOperation(() =&gt; &#123;</span><br><span class="line">  const startCallback = Date.now();</span><br><span class="line"></span><br><span class="line">  // do something that will take 10ms...</span><br><span class="line">  while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    // do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里EventLoop进入poll阶段的时候，由于队列为空（I/O需要95ms，还没进行完），所以会阻塞在这里，等待95ms的timer，在90ms的时候，I/O执行完了，将callback加入了poll队列里面，开始执行I/O的callback，这个callback耗时10ms，执行完成后，会去检测timer，发现这时候timer已经可以执行了，这时候开始执行timer，所以真正执行timer是在105ms的时候，而不是100ms。</p>
<h4 id="I-O阶段"><a href="#I-O阶段" class="headerlink" title="I/O阶段"></a>I/O阶段</h4><p>执行类似于TCP error的操作，比如TCP的连接接收到<code>ECONNREFUSED</code>，就会将该callback放入这个队列去执行。</p>
<h4 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a>poll阶段</h4><p>执行到期的timer，然后处理poll queue中的event。</p>
<ul>
<li><p>进入poll阶段的时候，如果没有timer</p>
<ul>
<li>poll队列不为空，则执行poll队列中的callback</li>
<li>poll队列为空<ul>
<li>如果存在setImmediate()的回调，则会结束poll阶段，进入到check阶段</li>
<li>如果不存在setImmediate()的回调，则会一直阻塞在这里，直到有callback加入队列</li>
</ul>
</li>
</ul>
</li>
<li><p>poll队列为空的时候，如果有timer</p>
<ul>
<li>poll队列为空的时候，检测timer队列，如果有超时的，则会wrap back to timer阶段去执行</li>
</ul>
</li>
</ul>
<h4 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h4><p>当poll阶段处于空闲状态的时候，会立即执行setImmediate()的callback。执行完后，如果队列为空，会回到poll阶段。</p>
<h4 id="close阶段"><a href="#close阶段" class="headerlink" title="close阶段"></a>close阶段</h4><p>socket或者handle突然关闭(e.g. socket.destroy())，close event会在这个阶段去发送，否则会通过process.nextTick()发送close event。</p>
<h4 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate() vs setTimeout()"></a>setImmediate() vs setTimeout()</h4><ul>
<li>setImmediate 设计在poll阶段完成时执行，即check阶段</li>
<li>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行</li>
</ul>
<p>二者的调用顺序取决于当前event loop的上下文，如果他们在异步I/O callback之外调用，其执行先后顺序是不确定的。如果在I/O callback内调用，则永远都是setImmediate()先执行。</p>
<p>不在I/O callback内执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;immediate&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>在I/O callback内调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;timeout&apos;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;immediate&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>process.nextTick()会在每个阶段执行。</p>
<p>使用process有时候会带来便利：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">// this has an asynchronous signature, but calls callback synchronously</span><br><span class="line">function someAsyncApiCall(callback) &#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line">// the callback is called before `someAsyncApiCall` completes.</span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line">  // since someAsyncApiCall has completed, bar hasn&apos;t been assigned any value</span><br><span class="line">  console.log(&apos;bar&apos;, bar); // undefined</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;bar&apos;, bar); // 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br></pre></td></tr></table></figure>
<p>创建服务器的时候，使用了process.nextTick();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class="line">server.on(&apos;listening&apos;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>当端口传过去的时候，会立马绑定，这时候会发出listening事件，然而这时候.on(‘listening’) callback还没有设置，这时候就需要在process.nextTick()中去发送listening事件。</p>
<h3 id="从node源码分析"><a href="#从node源码分析" class="headerlink" title="从node源码分析"></a>从node源码分析</h3><p>入口文件<code>src/node_main.cc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">#if defined(__linux__)</span><br><span class="line">  char** envp = environ;</span><br><span class="line">  while (*envp++ != nullptr) &#123;&#125;</span><br><span class="line">  Elf_auxv_t* auxv = reinterpret_cast&lt;Elf_auxv_t*&gt;(envp);</span><br><span class="line">  for (; auxv-&gt;a_type != AT_NULL; auxv++) &#123;</span><br><span class="line">    if (auxv-&gt;a_type == AT_SECURE) &#123;</span><br><span class="line">      node::linux_at_secure = auxv-&gt;a_un.a_val;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  // Disable stdio buffering, it interacts poorly with printf()</span><br><span class="line">  // calls elsewhere in the program (e.g., any logging from V8.)</span><br><span class="line">  setvbuf(stdout, nullptr, _IONBF, 0);</span><br><span class="line">  setvbuf(stderr, nullptr, _IONBF, 0);</span><br><span class="line">  return node::Start(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>接收参数，对参数进行初步解析，传给node::Start函数。</p>
<p><code>src/node.cc</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">node::Start(int argc, char** argv) &#123;</span><br><span class="line">//....</span><br><span class="line">  </span><br><span class="line">    Init(&amp;argc, const_cast&lt;const char**&gt;(argv), &amp;exec_argc, &amp;exec_argv);</span><br><span class="line"></span><br><span class="line">    const int exit_code =</span><br><span class="line">      Start(uv_default_loop(), argc, argv, exec_argc, exec_argv);</span><br><span class="line">//...</span><br><span class="line">return exit_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造uv_default_loop()，也就是EventLoop。<br><code>deps/uv/src/uv-common.c</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static uv_loop_t default_loop_struct;</span><br><span class="line">static uv_loop_t* default_loop_ptr;</span><br><span class="line"></span><br><span class="line">uv_loop_t* uv_default_loop(void) &#123;</span><br><span class="line">  if (default_loop_ptr != NULL)</span><br><span class="line">    return default_loop_ptr;</span><br><span class="line"></span><br><span class="line">  if (uv_loop_init(&amp;default_loop_struct))</span><br><span class="line">    return NULL;</span><br><span class="line"></span><br><span class="line">  default_loop_ptr = &amp;default_loop_struct;</span><br><span class="line">  return default_loop_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>uv_loop_t</code>的结构：<br><code>deps/uv/include/uv.h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct uv_loop_s uv_loop_t;</span><br><span class="line">struct uv_loop_s &#123;</span><br><span class="line">  /* User data - use this for whatever. */</span><br><span class="line">  void* data;</span><br><span class="line">  /* Loop reference counting. */</span><br><span class="line">  unsigned int active_handles;</span><br><span class="line">  void* handle_queue[2];</span><br><span class="line">  void* active_reqs[2];</span><br><span class="line">  /* Internal flag to signal loop stop. */</span><br><span class="line">  unsigned int stop_flag;</span><br><span class="line">  UV_LOOP_PRIVATE_FIELDS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>deps/uv/include/uv-unix.h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#define UV_LOOP_PRIVATE_FIELDS                                                \</span><br><span class="line">  unsigned long flags;                                                        \</span><br><span class="line">  int backend_fd;                                                             \</span><br><span class="line">  void* pending_queue[2];                                                     \</span><br><span class="line">  void* watcher_queue[2];                                                     \</span><br><span class="line">  uv__io_t** watchers;                                                        \</span><br><span class="line">  unsigned int nwatchers;                                                     \</span><br><span class="line">  unsigned int nfds;                                                          \</span><br><span class="line">  void* wq[2];                                                                \</span><br><span class="line">  uv_mutex_t wq_mutex;                                                        \</span><br><span class="line">  uv_async_t wq_async;                                                        \</span><br><span class="line">  uv_rwlock_t cloexec_lock;                                                   \</span><br><span class="line">  uv_handle_t* closing_handles;                                               \</span><br><span class="line">  void* process_handles[2];                                                   \</span><br><span class="line">  void* prepare_handles[2];                                                   \</span><br><span class="line">  void* check_handles[2];                                                     \</span><br><span class="line">  void* idle_handles[2];                                                      \</span><br><span class="line">  void* async_handles[2];                                                     \</span><br><span class="line">  void (*async_unused)(void);  /* TODO(bnoordhuis) Remove in libuv v2. */     \</span><br><span class="line">  uv__io_t async_io_watcher;                                                  \</span><br><span class="line">  int async_wfd;                                                              \</span><br><span class="line">  struct &#123;                                                                    \</span><br><span class="line">    void* min;                                                                \</span><br><span class="line">    unsigned int nelts;                                                       \</span><br><span class="line">  &#125; timer_heap;                                                               \</span><br><span class="line">  uint64_t timer_counter;                                                     \</span><br><span class="line">  uint64_t time;                                                              \</span><br><span class="line">  int signal_pipefd[2];                                                       \</span><br><span class="line">  uv__io_t signal_io_watcher;                                                 \</span><br><span class="line">  uv_signal_t child_watcher;                                                  \</span><br><span class="line">  int emfile_fd;                                                              \</span><br><span class="line">  UV_PLATFORM_LOOP_FIELDS                                                     \</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node::Start(uv_loop_t* event_loop,</span><br><span class="line">                 int argc, const char* const* argv,</span><br><span class="line">                 int exec_argc, const char* const* exec_argv) &#123;</span><br><span class="line">    IsolateData isolate_data(</span><br><span class="line">        isolate,</span><br><span class="line">        event_loop,</span><br><span class="line">        v8_platform.Platform(),</span><br><span class="line">        allocator.zero_fill_field());</span><br><span class="line">    if (track_heap_objects) &#123;</span><br><span class="line">      isolate-&gt;GetHeapProfiler()-&gt;StartTrackingHeapObjects(true);</span><br><span class="line">    &#125;</span><br><span class="line">    exit_code = Start(isolate, &amp;isolate_data, argc, argv, exec_argc, exec_argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IsolateData是V8中的概念，代表一个独立的虚拟机，对应一个或多个线程。但同一时刻 只能被一个线程进入。所有的 Isolate 彼此之间是完全隔离的, 它们不能够有任何共享的资源。如果不显示创建 Isolate, 会自动创建一个默认的 Isolate。</p>
<p><code>src/node.cc</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">inline int Start(Isolate* isolate, IsolateData* isolate_data,</span><br><span class="line">                 int argc, const char* const* argv,</span><br><span class="line">                 int exec_argc, const char* const* exec_argv) &#123;</span><br><span class="line">//...</span><br><span class="line">    &#123;</span><br><span class="line">    SealHandleScope seal(isolate);</span><br><span class="line">    bool more;</span><br><span class="line">    PERFORMANCE_MARK(&amp;env, LOOP_START);</span><br><span class="line">    do &#123;</span><br><span class="line">      uv_run(env.event_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">      v8_platform.DrainVMTasks(isolate);</span><br><span class="line"></span><br><span class="line">      more = uv_loop_alive(env.event_loop());</span><br><span class="line">      if (more)</span><br><span class="line">        continue;</span><br><span class="line"></span><br><span class="line">      EmitBeforeExit(&amp;env);</span><br><span class="line"></span><br><span class="line">      // Emit `beforeExit` if the loop became alive either after emitting</span><br><span class="line">      // event, or after running some callbacks.</span><br><span class="line">      more = uv_loop_alive(env.event_loop());</span><br><span class="line">    &#125; while (more == true);</span><br><span class="line">    PERFORMANCE_MARK(&amp;env, LOOP_EXIT);</span><br><span class="line">  &#125;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>deps/uv/src/unix/core.c</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123;</span><br><span class="line">  int timeout;</span><br><span class="line">  int r;</span><br><span class="line">  int ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  if (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = 0;</span><br><span class="line">    if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    if (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      /* UV_RUN_ONCE implies forward progress: at least one callback must have</span><br><span class="line">       * been invoked when it returns. uv__io_poll() can return without doing</span><br><span class="line">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span><br><span class="line">       * have pending timers that satisfy the forward progress constraint.</span><br><span class="line">       *</span><br><span class="line">       * UV_RUN_NOWAIT makes no guarantees about progress so it&apos;s omitted from</span><br><span class="line">       * the check.</span><br><span class="line">       */</span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* The if statement lets gcc compile it to a conditional store. Avoids</span><br><span class="line">   * dirtying a cache line.</span><br><span class="line">   */</span><br><span class="line">  if (loop-&gt;stop_flag != 0)</span><br><span class="line">    loop-&gt;stop_flag = 0;</span><br><span class="line"></span><br><span class="line">  return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>deps/uv/src/unix/core.c</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int uv__run_pending(uv_loop_t* loop) &#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  uv__io_t* w;</span><br><span class="line"></span><br><span class="line">  if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  while (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, uv__io_t, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>deps/uv/src/unix/linux-core.c</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void uv__io_poll(uv_loop_t* loop, int timeout) &#123;</span><br><span class="line">  while (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, uv__io_t, watcher_queue);</span><br><span class="line">   </span><br><span class="line">    e.events = w-&gt;pevents;</span><br><span class="line">    e.data = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">    if (w-&gt;events == 0)</span><br><span class="line">      op = UV__EPOLL_CTL_ADD;</span><br><span class="line">    else</span><br><span class="line">      op = UV__EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    /* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching</span><br><span class="line">     * events, skip the syscall and squelch the events after epoll_wait().</span><br><span class="line">     */</span><br><span class="line">    if (uv__epoll_ctl(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)) &#123;</span><br><span class="line">      if (errno != EEXIST)</span><br><span class="line">        abort();</span><br><span class="line"></span><br><span class="line">      assert(op == UV__EPOLL_CTL_ADD);</span><br><span class="line"></span><br><span class="line">      /* We&apos;ve reactivated a file descriptor that&apos;s been watched before. */</span><br><span class="line">      if (uv__epoll_ctl(loop-&gt;backend_fd, UV__EPOLL_CTL_MOD, w-&gt;fd, &amp;e))</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;events = w-&gt;pevents;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><p>表现形式一样</p>
<p>实现不一样</p>
<p>node中事件循环依靠libuv引擎，多个队列，没有微任务和宏任务的划分。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick" target="_blank" rel="noopener">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick</a></p>
<p><a href="https://yjhjstz.gitbooks.io/deep-into-node/chapter2/chapter2-0.html" target="_blank" rel="noopener">https://yjhjstz.gitbooks.io/deep-into-node/chapter2/chapter2-0.html</a></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/nodejs/">nodejs</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/08/23/css-layout/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">那些年忽略的CSS</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2018/05/15/nodejs-server-base/">
        <span class="next-text nav-default">Nodejs之web服务基础</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2018
    <span class="footer-author">FEGO.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
