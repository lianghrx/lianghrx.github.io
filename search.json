[{"title":"Redux源码分析","url":"/2018/12/05/redux-code-view/","content":"\nRedux是一个状态管理工具，或许大家已经比较熟悉了它的使用方式，比如创建`store`、派发`action`、利用`reducer`更新`state`等等。\n\n## 工作流\n\n我们先通过一段代码, 看一下redux是如何使用的\n```javascript\n/* store */\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { Provider } from 'react-redux';\nimport thunk from 'redux-thunk';\nimport reducers from './reducers';\n\n// 初始化state\nconst initialState = { ... };\n\n// 自定义中间件\nconst logger = store => next => action => {\n  console.info('触发行为', action);\n  return next(action);\n};\n\n// 实例化store\nconst store = createStore(\n  reducers,\n  initialState,\n  applyMiddleware( thunk, logger ),\n);\n\n// 通过Provider给应用绑定store\nclass App extends Component {\n  render() {\n    return (\n      <Provider store={store}>\n        <Router history={history} routes={routes} />\n      </Provider>\n    )\n  }\n}\n```\n```javascript\n/* reducer */\nimport { combineReducers } from 'redux';\nimport { routerReducer as routing } from 'react-router-redux';\n\n// 通过combineReducers合并多个reducer, 返回包装后的reducer\nexport default combineReducers({ routing, ... });\n```\n```javascript\n/* page */\nimport React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { bindActionCreators } from 'redux'\nimport actions from './action'\n\nclass Page extends Component { ... }\n\n// 注册模块, 获得state & dispatch\nexport default connect(\n  state => ({ page: state.page }),\n  dispatch => ({ actions: bindActionCreators(actions, dispatch) })\n)(Page)\n```\n通过一张图了解Redux是如何工作的\n\n![image](/images/redux-react.png)\n\n## Redux源码\n\nredux的代码比较精炼, 按功能分为四部分\n* createStore.js \b创建`store`, 注册监听函数, 提供原始`dispatch`函数等\n* combineReducers.js `reducer`的包装函数, \b更新`state`\n* applyMiddleware.js `store`的修饰函数, 注册中间件\n* compose.js 组合函数, 接受函数数组, 返回一个包装后的函数\n* bindActionCreators.js 给`actionCreator`绑定`dispatch`\n\n其中前三个是核心功能，下面我们依次解读\u001c源码。\n\n### createStore.js\n\n提供`createStore`方法, 创建新的`store`对象\n\n```javascript\nexport default function createStore(reducer, preloadedState, enhancer) {\n  // 处理参数顺序\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  /* ... */\n}\n```\n\n它接收三个参数:\n* `reducer`, 包装后的`reducer`函数\n* `preloadedState`, 初始化的`state`对象\n* `enhancer`, `store`的修饰函数, 添加中间件\n\n在`createStore`中定义了一些重要的方法和属性\n\n**getState**\n\n获取当前`store`维护的数据对象`state`\n\n```javascript\n/**\n  * Reads the state tree managed by the store.\n  *\n  * @returns {any} The current state tree of your application.\n  */\nfunction getState() {\n  return currentState\n}\n```\n\n**dispatch**\n\n原始dispatch函数, 其功能如下: \n* 检查`action`类型\n* 调用包装后的`reducer`, 更新`state`\n* 调用监听函数队列\n\n```javascript\nlet currentReducer = reducer    // 包装后的reducer入口函数\nlet currentState = preloadedState   // 当前store维护的数据对象\nlet currentListeners = []   // 当前的监听函数队列\nlet nextListeners = currentListeners    // 即将生效的监听函数队列\nlet isDispatching = false   // 派发事件的状态\n\nfunction dispatch(action) {\n  // 处理action, 更新state\n  try {\n    isDispatching = true\n    currentState = currentReducer(currentState, action)\n  } finally {\n    isDispatching = false\n  }\n  // 调用所有的监听函数, 触发回调事件\n  const listeners = (currentListeners = nextListeners)\n  for (let i = 0; i < listeners.length; i++) {\n    const listener = listeners[i]\n    listener()\n  }\n\n  return action\n}\n```\n\n**subscribe**\n\n注册的回调函数, 监听`dispatch`事件\n\n```javascript\nfunction ensureCanMutateNextListeners() {\n  if (nextListeners === currentListeners) {\n    nextListeners = currentListeners.slice()\n  }\n}\n\nfunction subscribe(listener) {\n  // 私有的注册状态\n  let isSubscribed = true\n  // 确保即将生效的监听函数队列可用\n  ensureCanMutateNextListeners()\n  nextListeners.push(listener)\n\n  // 返回监听事件的注销\b函数\n  return function unsubscribe() {\n    if (!isSubscribed) {\n      return\n    }\n\n    isSubscribed = false\n\n    ensureCanMutateNextListeners()\n    const index = nextListeners.indexOf(listener)\n    nextListeners.splice(index, 1)\n  }\n}\n```\n\n每当注册监听函数时, 会将其加入`nextListeners`队列; 在下次调用`dispatch`时, 将`nextListeners`的值更新到当前的监听函数队列`currentListeners`\n\n`createStore\b`调用完成之前, 会发出\b`ActionTypes.INIT`, 用于生成初始化的`state`对象.\n```javascript\n// When a store is created, an \"INIT\" action is dispatched so that every\n// reducer returns their initial state. This effectively populates\n// the initial state tree.\ndispatch({ type: ActionTypes.INIT })\n```\n\n### combineReducers.js\n\n该模块的核心功能如下:\n* 将多个`reducers`包装成一个新的`combine`函数, 接受两个参数`state`和`action`\n* 以`reducers`的函数名为`key`, 返回值为值, \b生成对应的`state`对象\n* \b被调用时, 将`state`根据`key`, 拆分成多个\b子`state`, 与`action`一起传递给对应的子`reducer`函数\n* `combine\b`函数可以作为\b`reducer`, 通过`combineReducers`生成新的`combine\b`, 形成`state tree`\n\n```javascript\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {} // \b当前层级的reducer集合\n\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // 返回新的reducer函数\n  return function combination(state = {}, action) {\n    let hasChanged = false\n    const nextState = {}\n\n    // 处理所有的reducer, 更新当前层级的state对象\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // hasChanged为true, 则返回新的state\n    return hasChanged ? nextState : state\n  }\n}\n```\n\n### applyMiddleware.js\n\n通过修饰函数, 为`store`添加中间件, 并在`dispatch`调用时依次执行\n\n```javascript\nexport default function applyMiddleware(...middlewares) {\n  // 返回store的修饰函数\n  return createStore => (...args) => {\n    const store = createStore(...args)\n\n    // 初始化\bfinal dispatch\n    let dispatch = () => {\n      throw new Error(\n        `Dispatching while constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to this dispatch.`\n      )\n    }\n\n    // 中间件参数\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args) // 封装一层的final dispatch, 作为中间件中的dispatch函数\n    }\n\n    // 初始化的中间件队列\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // \b\b中间件变为逐层调用的组合关系, 并包装原始的dispatch, 赋值给final dispatch\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n\n/* import from compose.js */\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  // 数组变为组合: [f, b, c, ...] => f(b(c(...)))\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n* `store`上的原始`dispatch`函数, \b经过中间件的包装, 生成了新的`dispatch`函数\n* `applyMiddleware\b`返回的修饰函数, 将`store\b.dispatch`替换成包装后的`dispatch`,\b 并返回新的`store`\n* 中间件的调用顺序为, 从左到右依次调用\n\n**Middleware**\n\n中间件的结构较为复杂, 它是由多层函数的**柯里化**构成, 我们以`redux-thunk`为例了解其实现机制\n\n```javascript\n/* redux-thunk */\nfunction createThunkMiddleware(extraArgument) {\n  // 返回中间件\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n\n* 包装层, 获得`store`实例, 在applyMiddleware中被调用, 生成用于中间件链式调用的传递函数\n* 传递层, 获得钩子函数`next`, 返回自身的调用钩子, 作为参数传递给下个中间件的传递函数\n* 逻辑层, 钩子函数（包装后的`dispatch`）, 获得`action`, 处理中间件业务逻辑, 调用上一个中间件的钩子`next(action)`, 形成链式调用直至`store.dispatch(action)`\n\n![image](/images/redux-middleware.png)\n\n### bindActionCreators.js\n\n给`actionCreator`绑定`dispatch\b`函数\n\n```javascript\nfunction bindActionCreator(actionCreator, dispatch) {\n  // 返回绑定后的函数, 可以直接调用, 派发action\n  return (...args) => dispatch(actionCreator(...args))\n}\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  const keys = Object.keys(actionCreators)\n  const boundActionCreators = {}\n  // 逐个绑定actionCreator\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  // 返回绑定后的actionCreators对象, 结构与之前一样\n  return boundActionCreators\n}\n```\n\n这个概念就比较简单了\n* 判断`actionCreators`类型，若为函数，直接返回绑定后的`function`\n* 若`actionCreators`为对象，依次给属性对应的函数绑定`dispatch`，并返回新生成的map对象\n* 绑定后的`actionCreator\b`, 可以直接调用并派发`action`\n\n## react-redux\n\n`Redux`是一个独立的数据管理工具, 如果想让它和`React`一起工作, 需要引入`react-redux`模块, 它主要提供`Provider`和`connect`两个API.\n\n**Provider**\n\n本身为`ReactComponent`, 通过`context`为子元素提供`store`对象\n\n```javascript\nexport default class Provider extends Component {\n  getChildContext() {\n    return { store: this.store }\n  }\n\n  constructor(props, context) {\n    super(props, context)\n    this.store = props.store\n  }\n\n  render() {\n    // 只允许有一个子元素\n    return Children.only(this.props.children)\n  }\n}\n\nProvider.propTypes = {\n  store: storeShape.isRequired,\n  children: PropTypes.element.isRequired\n}\n\nProvider.childContextTypes = {\n  store: storeShape.isRequired\n}\n```\n\n**connect**\n\n修饰函数, 为`ReactComponent`提供`state`和`dispatch`, 并将修饰后的属性合并到`ReactComponent`的`props`上\n\n```javascript\nexport default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n\n  /* ... */\n\n  // 包装函数\n  return function wrapWithConnect(WrappedComponent) {\n    return class Connect extends Component {\n      constructor(props, context) {\n        super(props, context)\n        this.version = version\n        this.store = props.store || context.store   // 获取store\n\n        const storeState = this.store.getState()\n        this.state = { storeState }   // 初始化state\n        this.clearCache()\n      }\n      computeStateProps() { ... }\n      computeDispatchProps() { ... }\n      render() {\n        /* ... */\n        this.renderedElement = createElement(WrappedComponent,\n          this.mergedProps\n        );\n        return this.renderedElement\n      }\n      trySubscribe() {\n        if (shouldSubscribe && !this.unsubscribe) {\n          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))\n          this.handleChange()\n        }\n      }\n      tryUnsubscribe() {\n        if (this.unsubscribe) {\n          this.unsubscribe()\n          this.unsubscribe = null\n        }\n      }\n      handleChange() {\n        if (!this.unsubscribe) return\n        const storeState = this.store.getState()\n        const prevStoreState = this.state.storeState\n        if (prevStoreState === storeState) return\n        this.hasStoreStateChanged = true\n        this.setState({ storeState })\n      }\n    }\n  }\n}\n```\n\n**react + redux**\n\n在入口文件中使用`Provider`, 为`App`中的所有子元素提供`store`对象\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n);\n```\n\n对需要用到`redux`状态管理的`ReactComponent`使用`connect`进行包装, 通过`mapStateToProps`和`mapDispatchToProps`参数/方法, 将处理后的`state`和`dispatch`合并到`ReactComponent`的`props`上\n\n```javascript\nimport { connect } from \"react-redux\";\nimport { increment, decrement, reset } from \"./actionCreators\";\n\n// const Counter = ...\n\nconst mapStateToProps = (state /*, ownProps*/) => {\n  return {\n    counter: state.counter\n  };\n};\n\n/*\n * 该参数为对象时, react-redux内部通过bindActionCreators绑定dispatch\n * 该参数为函数时, 接受dispatch作为参数, 返回已绑定dispatch的actions\n**/\nconst mapDispatchToProps = { increment, decrement, reset };\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Counter);\n```\n","tags":["redux"]},{"title":"Javascript中的对象、函数以及类的继承","url":"/2018/11/27/object-inherit/","content":"\n\n## **JS的类**\n在研究继承之前, 我们先看一下Javascript中的类是如何实现的\n\n**ES6**\n```javascript\nclass A {\n  constructor() {\n    this.name = 'class A';\n  }\n  toString() {\n    console.log(this.name)\n  }\n}\n```\n**ES5**\n```javascript\n/* ..._createClass... */\n/* ..._classCallCheck... */\n\nvar A = (function() {\n  function A() {\n    _classCallCheck(this, A);\n\n    this.name = \"class A\";\n  }\n\n  _createClass(A, [\n    {\n      key: \"toString\",\n      value: function toString() {\n        console.log(this.name);\n      }\n    }\n  ]);\n\n  return A;\n})();\n```\n\n使用`new`操作符生成类的实例对象\n```javascript\nconst a = new A();\n\na.toString()    // class A\na.__proto__ === A.prototype   // true\n```\n**类是一种特殊的函数, 通过new关键字调用函数产生新实例对象, 通过this访问对象的属性和方法, 最后返回该对象**\n\n## **原型链**\nJavascript中的继承是通过原型链实现的。\n\n**ES6**\n```javascript\nclass A {}\n\nclass B extends A {}\n```\n**ES5**\n```javascript\nvar A = function A() {\n  _classCallCheck(this, A);\n};\n\nvar B = (function(_A) {\n  _inherits(B, _A);   // 继承的实现\n\n  function B() {\n    _classCallCheck(this, B);\n\n    return _possibleConstructorReturn(\n      this,\n      (B.__proto__ || Object.getPrototypeOf(B)).apply(this, arguments)\n    );\n  }\n\n  return B;\n})(A);\n\n/* _possibleConstructorReturn */\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  // \b原型的继承 (私有方法和属性)\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {    // constructor指向subClass构造函数\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  // \b类的继承 (静态方法和属性)\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n```\n在`_inherits`函数的代码中可以看到, 类的继承是通过两条原型链实现的\n1. 私有方法的原型链\n```\nconst a = new A();\nconst b = new B();\n\nb.__proto__ === B.prototype   // true\n\nB.prototype instanceof A    // true\nB.prototype.__proto__ === A.prototype   // true\nb.__proto__.__proto__ === A.prototype   // true\n\nb instanceof B    // true\nb instanceof A    // ???\n```\n2. 静态方法的原型链\n```\nA.print = () => { console.log('print, static in A') }\nA.test = () => { console.log('test, static in A') }\nB.test = () => { console.log('test, static in B') }\n\nB.test()    // test, static in B\nB.print()   // ???\n```\n**类继承的实现方式已经比较清楚了**\n* 通过\b类的`prototype`属性, 构造出类实例\b的原型链, 实现私有属性的继承\n* 通过类的`__proto__`属性, 构造出类的原型链, 实现静态属性的继承\n\n**继承关系（B extends A）**\n![image](/images/object-inherit.png)\n\n## instanceof的原理\n\n引用MDN\b文档中关于`instanceof`操作符的解释\n\n`instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置`\n\n`A.prototype`存在于b的`__proto__`原型链上, 所以\n\n```\nb instanceof A    // true\n\n// B.prototype赋值为A的新实例\nB.prototype = Object.create(A.prototype, {\n  constructor: {\n    value: B,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n});\n\nb instanceof B    // ???\nb instanceof A    // ???\n```\n\n## Object & Function\n\n**Javascript中一切都是对象, 包括函数**, 更准确的说法是:\n\n1. 除了原始类型外, 都是对象（Array, Object, Function等）\n2. 除了`null`和`undefined`, 原始类型在使用时可以被包装成对象（String, Number, Boolean等）\n\n这里的主题是**函数**与**对象**的关系\n\n**Object是对象的构造函数, Function是函数的构造函数**\n\n* Object是一个函数, 那它是Function的一个实例吗?\n* Object也是一个对象, 那它会不会是自己的一个实例？\n* Function是函数也是对象, 那么它又是谁的实例呢？是Function？还是Object？\n\n我们从原型和继承的角度, 分析一下Object和Function之间的关系。\n\n**Object与Function的关系**\n```javascript\nObject instanceof Function    // true\nFunction instanceof Object    // true\n\nObject instanceof Object    // true\nFunction instanceof Function    // true\n\n/* 原型 */\nORIGIN_OBJECT = Object.prototype    // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …}\nORIGIN_FUNCTION = Function.prototype    // ƒ () { [native code] }\n\nORIGIN_OBJECT.__proto__   // null\nORIGIN_FUNCTION.__proto__   // ORIGIN_OBJECT\n\nORIGIN_FUNCTION instaceof Function    // false\nORIGIN_FUNCTION instaceof Object    // true\n\nORIGIN_FUNCTION()   // undefined\n\nnew ORIGIN_FUNCTION()   // Uncaught TypeError: Function.prototype is not a constructor\nORIGIN_FUNCTION.prototype   // undefined\n\n/* 原型链 */\nObject.__proto__ === Function.prototype   // ORIGIN_FUNCTION\nFunction.__proto__ === Function.prototype   // ORIGIN_FUNCTION\nFunction.prototype.__proto__ === Object.prototype   // ORIGIN_OBJECT\nObject.prototype.__proto__ === null   // null\n```\n我们得到了两个最原始的**对象**类型:\n* `{constructor: ƒ, __defineGetter__: ƒ, …}`, 原始对象, 处于原型链上描述Object类型, 所有原型链的终点\n* `ƒ () { [native code] }`, 原始函数, 处于原型链上描述Function类型, 与关键字new的构造函数实例化有关\n\n**构造函数实例化**\n\n这里有两个比较重要的属性\n* `prototype`, 作为构造函数, 用于实例化时生成原型链`__proto__`\n* `__proto__`, 作为函数实例, 指向Function.prototype, 形成原型链\n\n```javascript\n/* Object实例化 */\nconst o = new Object();\no.__proto__ === Object.prototype\n\n/* Function实例化 */\nconst fn = new Function()\nfn.__proto__ === Function.prototype\nfn.prototype.__proto__ === Object.prototype   // fn.prototype = Object.create(Object.prototype, { constructor: fn })\n\n/* fn实例化 */\nconst t = new fn()\nt.__proto__ === fn.prototype\nt.__proto__.__proto__ === Object.prototype\n```\n\nObject的实例化较为简单:\n* 生成新实例对象, 其`__proto__`指向`Object.prototype`\n* 实例对象为Object类型\n\nFunction的实例化稍有不同:\n* 生成新实例对象, 其`__proto__`指向`Function.prototype`\n* 实例对象（fn）为Function类型, 可执行实例化生成新对象（Object类型）\n* 将fn的`prototype`属性赋值为Object类型的对象, 并将`prototype.constructor`指向fn自身\n\n**函数是一类特殊的Object, 它的实例是一个对象; Function是一个特殊的函数, 它的实例是一个函数类型的对象**\n* `Object.prototype`和`Function.prototype`是两段原生代码（原生对象类型）, 都位于原型链上, 分别作为`Object`和`Function`的类型判断依据\n* `Object`是个函数类型的对象, 可以看做`Function`的一个实例, 那么`Object.__proto__ = Function.prototype`符合自身为函数类型\n* `Function`是个函数类型的对象, 可以看做`Function`的一个实例, 那么`Function.__proto__ = Function.prototype`符合自身为函数类型\n* `Object`和`Function`都是对象, `Object.prototype`应该存在于原型链上, 那么`Function.prototype.__proto__ = Object.prototype`符合自身为对象类型\n* `Function`的实例为`fn`, 那么`Function.prototype`和`Object.prototype`都在`fn`的原型链上, 符合`Function`的实例是函数也是对象\n\n通过一张图来说明Object、Function及其实例的关系\n![image](/images/object-function.png)\n","tags":["javascript"]},{"title":"那些年忽略的CSS","url":"/2018/08/23/css-layout/","content":"\n## 碎碎念\n>CSS的学习入门很容易，只要1年甚至半年的时候，我们就能根据设计图迅速切出页面，能熟练使用些CSS hack，这个阶段我们的成长很快，每天都能汲取新知识。这实际上是CSS非常初级的阶段，也是广大页面仔们（包括我本人😳）最为浮躁，最自以为是，最觉得CSS不过如此的阶段。所以我们要增加学习的深度，深入掌握细节和原理，当我们对CSS的底层表现有一定的理解与认识的时候，遇到一些看似奇怪的问题，可以轻松搞定~\n\n# 布局\n\n我们在研究布局之前，首先需要了解几个很重要的概念和属性：\n\n## 文档流\n文档流指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中从左至右的顺序排放元素。HTML中全部元素都是盒模型，盒模型占用一定的空间，依次排放在HTML中，形成了文档流。\n\n`float`、`position：absolute|fixed`是脱离文档流的。脱离文档流是指，这个标签脱离了文档流的管理。不受文档流的布局约束了，并且更重要的一点是，当一个元素脱离文档流后，这个标签在原文档流中所占的空间也被清除掉了，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。\n\n#### 块级元素\n- 每个块级元素都是独自占一行，其后的元素也只能另起一行，并不能两个元素共用一行。\n- 元素的高度、宽度、行高和顶底边距都是可以设置的。\n- 元素的宽度如果不设置的话，默认为父元素的宽度\n- 常见的块级元素：`<div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>`\n\n#### 行级元素\n- 可以和其他元素处于一行，不用必须另起一行。\n- 元素的高度、宽度及顶部和底部边距不可设置。\n- 元素的宽度就是它包含的文字、图片的宽度，不可改变。\n- 常见的行级元素:`<span>、<a>、<strong>、<em>`\n\n#### 行级元素与块级元素的转换\n\n- 可以在css样式中用display:inline将块级元素设为行级元素\n- 同样，也可以用display:block将行级元素设为块级元素\n\n#### display\n是CSS中最重要的用于控制布局的属性，每个元素都有一个默认的值，这与元素的类型有关。对于大多数元素它们的默认值通常是`block`(块级元素)或`inline`(行内元素)。\n\n\n`display:none` 和`visibility`属性不一样。`display:none`的元素不会占据它本来应该显示的空间，但是设置成`visibility: hidden;`还会占据空间。\n\n#### 外边距折叠\n如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失\n\n## 定位（position）\n\n- static：默认值。元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。\n\n- relative：元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。\n\n<div style=\"width: 700px;height:50px;line-height:50px;border:1px solid #ccc;position: relative;\">这是一个设置了 position: relative; 的div</div>\n<div style=\"width: 500px;padding:10px;border:1px solid #ccc;position: relative;top: -20px;left: 20px;\">这是一个设置了position:relative; top:-20px; left:20px; width: 500px;的div</div>\n\n- absolute：元素框不再占有文档流位置，并且相对于包含块进行偏移(所谓的包含块就是最近一级外层元素position不为static的元素)，找不到符合条件的父（祖先）节点，则相对浏览器窗口进行定位；没有设置TRBL，则默认浮动，默认浮动在父级节点的content-box区。\n- fixed：属性的值为fixed的元素会相对于视窗来定位，即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙（即脱离文档流），但是移动设备兼容性不好。\n- sticky：(这是css3新增的属性值)粘性定位，官方的介绍比较简单。其实，它就相当于relative和fixed混合。最初会被当作是relative，相对于原来的位置进行偏移；一旦超过一定阈值之后，会被当成fixed定位，相对于视口进行定位。\n\n## 浮动（float）\n最初，设计浮动时，其实并不是为了布局的，而是为了实现文字环绕的特效。类似于ps中的图层一样，浮动的元素会在浮动层上面进行排布，而在原先文档流中的元素位置，会被以某种方式进行删除，但是还是会影响布局，所以要记得清除浮动。\n\n浮动为什么会被使用在布局中呢？因为设置浮动后的元素会形成BFC（使得内部的元素不会被外部所干扰），并且元素的宽度也不再自适应父元素宽度，而是适应自身内容。这样就可以，轻松地实现多栏布局的效果。浮动通常用于创建多个列布局，并且由于它有良好的浏览器兼容性，已经被使用了相当一段时间。\n\n## flex布局\n弹性布局：用来为盒状模型提供最大的灵活性，采用 Flex 布局的元素，称为 Flex 容器（flex container）。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item）。\n\n![](https://user-gold-cdn.xitu.io/2018/8/28/1657fbd8aaaa003a?w=563&h=333&f=png&s=10005)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n项目(flex item)默认沿主轴排列。单个item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n### container(容器)的属性\n#### <strong style=\"color:#ff7373\">flex-direction</strong> \n\n属性决定主轴的方向（即item的排列方向）\n- row（默认值）：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n\n![](https://user-gold-cdn.xitu.io/2018/8/28/1657fd540c700b53?w=754&h=282&f=jpeg&s=34107)\n\n#### <strong style=\"color:#ff7373\">flex-wrap</strong> \n默认情况下，项目(item)都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n- nowrap（默认）：不换行。\n\n![](https://user-gold-cdn.xitu.io/2018/8/28/1657fddece76af97?w=233&h=65&f=jpeg&s=5212)\n- wrap：换行，第一行在上方。\n\n![](https://user-gold-cdn.xitu.io/2018/8/28/1657fde4c7d6c2a0?w=233&h=106&f=jpeg&s=6790)\n- wrap-reverse：换行，第一行在下方。\n\n![](https://user-gold-cdn.xitu.io/2018/8/28/1657fde7af8596bb?w=233&h=110&f=jpeg&s=7204)\n\n####  <strong style=\"color:#ff7373\">flex-flow</strong>\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`\n\n#### <strong style=\"color:#ff7373\">justify-content</strong>\n`justify-content`属性定义了项目在主轴上的对齐方式。\n```css\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/9/6/165aca3bac8168fa?w=902&h=499&f=jpeg&s=41688\" width=800 style=\"display:block;margin:auto\"/>\n\n#### <strong style=\"color:#ff7373\">align-items</strong>\n`align-items`属性定义项目在交叉轴上如何对齐。\n```css\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/8/28/1657fe28914dc972?w=617&h=786&f=png&s=8343\" width=500 style=\"display:block;margin:auto\"/>\n\n#### <strong style=\"color:#ff7373\">align-content</strong>\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n```css\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n- flex-start：元素位于容器的开头。各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行。\n- flex-end：元素位于容器的结尾。各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行。\n- center：元素位于容器的中心。各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离。）\n- space-between：元素位于各行之间留有空白的容器内。各行在弹性盒容器中平均分布。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于'flex-start'。在其它情况下，第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等。\n- space-around：元素位于各行之前、之间、之后都留有空白的容器内。各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于'center'。在其它情况下，各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半。\n- stretch（默认值）：元素被拉伸以适应容器。各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于'flex-start'。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。\n\n![](https://user-gold-cdn.xitu.io/2018/8/28/16580076cc3b7d59?w=460&h=600&f=jpeg&s=47298)\n\n### item(项目)的属性\n#### <strong style=\"color:#ff7373\">order</strong>\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n#### <strong style=\"color:#ff7373\">flex-grow</strong>\n`flex-grow`属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n<img src=\"https://user-gold-cdn.xitu.io/2018/8/29/165839dbaea97e27?w=802&h=211&f=png&s=7337\" width=400 style=\"display:block;margin:auto\"/>\n#### <strong style=\"color:#ff7373\">flex-shrink</strong>\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。**负值对该属性无效**\n\n#### <strong style=\"color:#ff7373\">flex-basis</strong>\n`flex-basis`属性用于设置或检索弹性盒伸缩基准值。定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n它可以设为一个长度单位或者一个百分比，规定灵活项目的初始长度。\n```css\ndiv:nth-of-type(2) {\n    flex-basis: 80px;\n}\n```\n<img src=\"https://user-gold-cdn.xitu.io/2018/8/29/16583a44d5f7240d?w=710&h=206&f=jpeg&s=13766\" width=400 style=\"display:block;margin:auto\"/>\n\n#### <strong style=\"color:#ff7373\">flex</strong>\n`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n该属性有两个快捷值：`auto `(`1 1 auto`) 和 `none` (`0 0 auto`)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n#### <strong style=\"color:#ff7373\">align-self</strong>\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\n- auto：默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 \"stretch\"。\n- stretch：元素被拉伸以适应容器。如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n- center：元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- flex-start：元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- baseline：元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n\n![](https://user-gold-cdn.xitu.io/2018/8/29/16583b23053d5d96?w=1083&h=267&f=jpeg&s=42577)\n\n## 布局技巧\n\n### 单列布局\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/8/17/16547379f55886cf?w=580&h=410&f=jpeg&s=27413\" width=400 style=\"display:block;margin:auto\"/>\n\n常见的这两种单列布局的特点都是**定宽**，**水平居中**的，设置width或max-width和margin:auto即可；\n\n### 二列&三列布局\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/8/17/16547573001367ea?w=542&h=513&f=jpeg&s=34135\" width=400 style=\"display:block;margin:auto\"/>\n二列布局的特征是侧边栏固定宽度，主栏自适应宽度。\n\n三列布局的特征是左右两侧固定宽度，中间列自适应宽度。\n\n#### 1.float + margin\n将两个侧边栏分别向左向右浮动，通过设置中间的主栏的margin为它们留出空间，形成三列布局\n```css\n.left{\n    float: left;\n    width: 200px;\n}\n.right{\n    float: right;\n    width: 200px;\n}\n.main{\n    margin-left: 220px; /*预留出定宽两栏的空间*/\n    margin-right: 220px;\n}\n```\n只设置一个浮动即可得到两列布局\n#### 2.position + margin\n通过将两个侧边栏的position设置为absolute，然后将左边栏的left设置为0，右边栏的right设置为0，主栏设置margin为边栏留出空间，即可得到三列布局。\n```css\n.left{\n    position: absolute;\n    left: 0;\n    width: 200px;\n}\n.right{\n    position: absolute;\n    right: 0;\n    width: 200px;\n}\n.main{\n    margin-left: 220px;\n    margin-right: 220px;\n}\n```\n同样，将定位元素改为一个可以得到两列布局。\n\n#### 圣杯布局\n- 三者都设置向左浮动。\n- 设置main宽度为100%，设置两侧栏的宽度。\n- 设置负边距，left设置负左边距为100%，right设置负左边距为负的自身宽度。\n- 设置main的padding值给左右两个子面板留出空间。\n- 设置两个子面板为相对定位，左边栏的left值为负的自身宽度，右边栏的right值为负的自身宽度。\n```html\n <div class=\"container\">         \n    <div class=\"main\"></div>        \n    <div class=\"left\"></div>        \n    <div class=\"right\"></div>  \n</div>\n```\n```css\n.main{\n    float: left;       \n    width: 100%;   \n}\n.left{     \n    float: left;        \n    width: 200px;        \n    margin-left: -100%;               \n    position: relative;  \n    left: -200px; \n}\n.right{\n    float: left;        \n    width: 300px;        \n    margin-left: -300px; \n    position: relative; \n    right: -300px;  \n}\n.container {        \n    padding: 0 300px 0 200px;   \n}\n```\n\n二列的实现方法：\n\n如果是左边带有侧栏的二列布局，则去掉right，不设置主面板的padding-right值。\n\n####  双飞翼布局\n双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在主栏外加了一层div并设置margin用来容纳侧栏，两侧栏的负边距都是相对于外层div而言，main的margin值变化便不会影响两个侧栏，这样就省略了将侧栏拉到主栏那一行后进行的relative定位（因为双飞翼布局留白就在父元素的内容区，而圣杯布局的留白在父元素内容区之外）。\n```html\n<div class=\"wrapper\">\n      <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>        \n<div class=\"right\"></div>\n```\n```css\n.wrapper {        \n    float: left;       \n    width: 100%;\n}  \n.main {    \n    margin: 0 300px 0 200px;\n}\n.left {       \n    float: left;        \n    width: 200px;        \n    margin-left: -100%;   \n}   \n.right {        \n    float: left;        \n    width: 300px;        \n    margin-left: -300px; \n }\n```\n- 圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。\n双飞翼布局不用设置相对布局，以及对应的left和right值。简单说起来就是“双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了”。\n- 如果引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 200px;,可以实现left+right+main的布局。\n\n二列的实现方法：\n\n如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。\n####  flex布局\nFlex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。除了在PC端兼容性较差，没有太大的缺陷，多用于移动端布局。\n\n```css\n.layout {\n    display: flex;\n}\n.main {\n    flex: 1;\n}\n.aside {\n    width: 200px;\n}\n```\n\n![](https://user-gold-cdn.xitu.io/2018/8/20/16556d8c7af65230?w=2558&h=1190&f=png&s=169081)\n\n\n### 常用居中方法\n\n#### margin: auto;\n\n<div style=\"width: 700px;height:50px;line-height:50px;text-align:center;margin: 0 auto;border:1px solid #ccc\">这是一个设置了\n  width: 600px;\n  margin: 0 auto; \n的div</div>\n\n这是大家很常见的居中方式，元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。**不过问题是**，当浏览器窗口比元素的宽度还要窄时，浏览器会显示水平滚动条。\n\n在这种情况下使用 max-width 替代 width 可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要~\n\n<div style=\"max-width: 700px;height:50px;line-height:50px;text-align:center;margin: 0 auto;border:1px solid #ccc\">这是一个设置了\n  max-width: 600px;\n  margin: 0 auto; \n的div</div>\n\n调整窗口大小看一下两者的区别吧\n居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：\n```html\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n```\n#### 水平居中\n- **子元素为行内元素**：对父元素设置text-align:center;\n- **子元素为定宽块状元素**: 设置左右margin值为auto;\n- **子元素为不定宽块状元素**: 设置子元素为display:inline,然后在父元素上设置text-align:center;\n- **通用方案**: flex布局，对父元素设置display:flex;justify-content:center;\n\n#### 垂直居中\n垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。\n\n- **父元素一定，子元素为单行内联文本**：设置父元素的height等于行高line-height\n- **父元素一定，子元素为多行内联文本**：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;\n- **块状元素**:设置子元素position:absolute 并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto;\n- **通用方案**: flex布局，给父元素设置{display:flex; align-items:center;}。\n","tags":["css"]},{"title":"Nodejs之EventLoop","url":"/2018/05/15/nodejs-event-loop/","content":"\n### 初识EventLoop\nEventLoop是一个程序结构，用于等待、发送消息和事件。\n\n事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB36bfba2beaca697929ad575a619f5f88?method=download&shareKey=75c7e9f235e0adaf39668432e519b866)\n\n### 从WebServer理解EventLoop\nNode JS构成的web服务器和传统的多线程服务器不一样，Node JS只有一个进程处理请求和响应。\n\nNode JS处理请求如下：\n1. client发送request到server\n2. server将requst放入名为EventQueue的队列\n3. EventLoop从EventQueue中取出request\n4. 如果request含有IO任务或者其他耗时，则从内部线程池中获取线程去处理该请求，一切处理完成后，将response发送回EventLoop\n5. 如果request中不含有耗时任务，则EventLoop会直接处理，将response发送给client。\n\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBfd1cd7fffbabbcf4ed4a394c7cfa5b29?method=download&shareKey=aed35c468e885549ac91f2f0a0123c1d)\n\n```\npublic class EventLoop {\n    while(true){\n        if(Event Queue receives a JavaScript Function Call){\n            ClientRequest request = EventQueue.getClientRequest();\n            If(request requires BlokingIO or takes more computation time)\n                Assign request to Thread T1\n            Else\n                Process and Prepare response\n        }\n    }\n} \n```\n\n#### 优点\n+ 对于多并发无压力\n+ 不会随着请求的增多而迅速增大开销\n+ 使用的线程比较少，所以占用的资源也比较少\n\n### EventLoop vs Worker Pool\nEventLoop 执行non-blocking的异步任务，一般为JavaScript的callback。\n\nWorker Pool在libuv中实现，Worker Pool中执行“expensive”任务，包含操作系统没提供异步处理的任务，比如I/O，数据库访问等，还有部分比较消耗CPU的任务。\n\n+ I/O集中的任务\n    + DNS : dns.lookup(), dns.lookupService().\n    + FileSystem\n+ CPU集中的任务\n    + Zlib\n    + Crypto\n\n\n### EventLoop各个阶段分析\n当Node启动的时候会初始化Event Loop，在初始化Event Loop的时候会执行一段传入进来的脚本，然后开始事件循环。\n\n事件循环的大体顺序如下：\n\n```\n   ┌───────────────────────┐\n┌─>│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │<─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\n```\n\n#### 理解要点：\n\n1. event loop 会分阶段执行，每个阶段都会有各自的FIFO队列\n2. 到达每个阶段后会一直执行，直到当前阶段队列为空，或者执行的callback达到了最大限度\n3. timers阶段涉及到的有setTimeout和setInterval\n4. I/O callback阶段执行除了close、timer、setImmediate相关回调的所有回调\n5. poll会获取新的I/O事件并执行，当队列为空的时候，会检测timer队列，如果timer对了不为空，并且已经到执行时间，则会执行timer。node有可能阻塞在这个阶段。\n6. check阶段执行setImmediate的回调\n7. close阶段执行所有的关闭回调，如socket的关闭\n8. process.nextTick比较特殊，在每个阶段的末尾执行。\n9. 官方建议使用setImediate代替process.nextTick。\n\n#### timer阶段\n\ntimer会指定一个阈值，当达到这个阈值的时候，就会去执行对应的callback，然而实际执行的过程中，timer什么时候执行是由poll阶段控制的。\n\n```\nconst fs = require('fs');\n\nfunction someAsyncOperation(callback) {\n  // Assume this takes 95ms to complete\n  fs.readFile('/path/to/file', callback);\n}\n\nconst timeoutScheduled = Date.now();\n\nsetTimeout(() => {\n  const delay = Date.now() - timeoutScheduled;\n\n  console.log(`${delay}ms have passed since I was scheduled`);\n}, 100);\n\n\n// do someAsyncOperation which takes 95 ms to complete\nsomeAsyncOperation(() => {\n  const startCallback = Date.now();\n\n  // do something that will take 10ms...\n  while (Date.now() - startCallback < 10) {\n    // do nothing\n  }\n});\n```\n\n这里EventLoop进入poll阶段的时候，由于队列为空（I/O需要95ms，还没进行完），所以会阻塞在这里，等待95ms的timer，在90ms的时候，I/O执行完了，将callback加入了poll队列里面，开始执行I/O的callback，这个callback耗时10ms，执行完成后，会去检测timer，发现这时候timer已经可以执行了，这时候开始执行timer，所以真正执行timer是在105ms的时候，而不是100ms。\n\n#### I/O阶段\n执行类似于TCP error的操作，比如TCP的连接接收到`ECONNREFUSED`，就会将该callback放入这个队列去执行。\n\n#### poll阶段\n执行到期的timer，然后处理poll queue中的event。\n\n+ 进入poll阶段的时候，如果没有timer\n    + poll队列不为空，则执行poll队列中的callback\n    + poll队列为空\n        + 如果存在setImmediate()的回调，则会结束poll阶段，进入到check阶段\n        + 如果不存在setImmediate()的回调，则会一直阻塞在这里，直到有callback加入队列\n\n+ poll队列为空的时候，如果有timer\n    + poll队列为空的时候，检测timer队列，如果有超时的，则会wrap back to timer阶段去执行\n\n#### check阶段\n\n当poll阶段处于空闲状态的时候，会立即执行setImmediate()的callback。执行完后，如果队列为空，会回到poll阶段。\n\n#### close阶段\nsocket或者handle突然关闭(e.g. socket.destroy())，close event会在这个阶段去发送，否则会通过process.nextTick()发送close event。\n\n#### setImmediate() vs setTimeout()\n+ setImmediate 设计在poll阶段完成时执行，即check阶段\n+ setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行\n\n二者的调用顺序取决于当前event loop的上下文，如果他们在异步I/O callback之外调用，其执行先后顺序是不确定的。如果在I/O callback内调用，则永远都是setImmediate()先执行。\n\n不在I/O callback内执行\n\n```\n// timeout_vs_immediate.js\nsetTimeout(() => {\n  console.log('timeout');\n}, 0);\n\nsetImmediate(() => {\n  console.log('immediate');\n});\n\n```\n\n```\n$ node timeout_vs_immediate.js\ntimeout\nimmediate\n\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\n```\n\n在I/O callback内调用\n\n```\n// timeout_vs_immediate.js\nconst fs = require('fs');\n\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log('timeout');\n  }, 0);\n  setImmediate(() => {\n    console.log('immediate');\n  });\n});\n```\n\n```\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\n\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\n```\n\n#### process.nextTick()\nprocess.nextTick()会在每个阶段执行。\n\n使用process有时候会带来便利：\n\n```\nlet bar;\n\n// this has an asynchronous signature, but calls callback synchronously\nfunction someAsyncApiCall(callback) { callback(); }\n\n// the callback is called before `someAsyncApiCall` completes.\nsomeAsyncApiCall(() => {\n  // since someAsyncApiCall has completed, bar hasn't been assigned any value\n  console.log('bar', bar); // undefined\n});\n\nbar = 1;\n```\n\n```\nlet bar;\n\nfunction someAsyncApiCall(callback) {\n  process.nextTick(callback);\n}\n\nsomeAsyncApiCall(() => {\n  console.log('bar', bar); // 1\n});\n\nbar = 1;\n```\n\n创建服务器的时候，使用了process.nextTick();\n\n```\nconst server = net.createServer(() => {}).listen(8080);\nserver.on('listening', () => {});\n```\n当端口传过去的时候，会立马绑定，这时候会发出listening事件，然而这时候.on('listening') callback还没有设置，这时候就需要在process.nextTick()中去发送listening事件。\n\n### 从node源码分析\n入口文件`src/node_main.cc`\n\n```\nint main(int argc, char *argv[]) {\n#if defined(__linux__)\n  char** envp = environ;\n  while (*envp++ != nullptr) {}\n  Elf_auxv_t* auxv = reinterpret_cast<Elf_auxv_t*>(envp);\n  for (; auxv->a_type != AT_NULL; auxv++) {\n    if (auxv->a_type == AT_SECURE) {\n      node::linux_at_secure = auxv->a_un.a_val;\n      break;\n    }\n  }\n#endif\n  // Disable stdio buffering, it interacts poorly with printf()\n  // calls elsewhere in the program (e.g., any logging from V8.)\n  setvbuf(stdout, nullptr, _IONBF, 0);\n  setvbuf(stderr, nullptr, _IONBF, 0);\n  return node::Start(argc, argv);\n}\n#endif\n```\n接收参数，对参数进行初步解析，传给node::Start函数。\n\n`src/node.cc`\n```\nnode::Start(int argc, char** argv) {\n//....\n  \n    Init(&argc, const_cast<const char**>(argv), &exec_argc, &exec_argv);\n\n    const int exit_code =\n      Start(uv_default_loop(), argc, argv, exec_argc, exec_argv);\n//...\nreturn exit_code;\n}\n```\n构造uv\\_default\\_loop()，也就是EventLoop。\n`deps/uv/src/uv-common.c`\n```\n\nstatic uv_loop_t default_loop_struct;\nstatic uv_loop_t* default_loop_ptr;\n\nuv_loop_t* uv_default_loop(void) {\n  if (default_loop_ptr != NULL)\n    return default_loop_ptr;\n\n  if (uv_loop_init(&default_loop_struct))\n    return NULL;\n\n  default_loop_ptr = &default_loop_struct;\n  return default_loop_ptr;\n}\n\n```\n`uv_loop_t`的结构：\n`deps/uv/include/uv.h`\n```\ntypedef struct uv_loop_s uv_loop_t;\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  void* active_reqs[2];\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\n\n```\n`deps/uv/include/uv-unix.h`\n```\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n  unsigned long flags;                                                        \\\n  int backend_fd;                                                             \\\n  void* pending_queue[2];                                                     \\\n  void* watcher_queue[2];                                                     \\\n  uv__io_t** watchers;                                                        \\\n  unsigned int nwatchers;                                                     \\\n  unsigned int nfds;                                                          \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;                                                        \\\n  uv_rwlock_t cloexec_lock;                                                   \\\n  uv_handle_t* closing_handles;                                               \\\n  void* process_handles[2];                                                   \\\n  void* prepare_handles[2];                                                   \\\n  void* check_handles[2];                                                     \\\n  void* idle_handles[2];                                                      \\\n  void* async_handles[2];                                                     \\\n  void (*async_unused)(void);  /* TODO(bnoordhuis) Remove in libuv v2. */     \\\n  uv__io_t async_io_watcher;                                                  \\\n  int async_wfd;                                                              \\\n  struct {                                                                    \\\n    void* min;                                                                \\\n    unsigned int nelts;                                                       \\\n  } timer_heap;                                                               \\\n  uint64_t timer_counter;                                                     \\\n  uint64_t time;                                                              \\\n  int signal_pipefd[2];                                                       \\\n  uv__io_t signal_io_watcher;                                                 \\\n  uv_signal_t child_watcher;                                                  \\\n  int emfile_fd;                                                              \\\n  UV_PLATFORM_LOOP_FIELDS                                                     \\\n```\n\n```\nnode::Start(uv_loop_t* event_loop,\n                 int argc, const char* const* argv,\n                 int exec_argc, const char* const* exec_argv) {\n    IsolateData isolate_data(\n        isolate,\n        event_loop,\n        v8_platform.Platform(),\n        allocator.zero_fill_field());\n    if (track_heap_objects) {\n      isolate->GetHeapProfiler()->StartTrackingHeapObjects(true);\n    }\n    exit_code = Start(isolate, &isolate_data, argc, argv, exec_argc, exec_argv);\n}\n```\nIsolateData是V8中的概念，代表一个独立的虚拟机，对应一个或多个线程。但同一时刻 只能被一个线程进入。所有的 Isolate 彼此之间是完全隔离的, 它们不能够有任何共享的资源。如果不显示创建 Isolate, 会自动创建一个默认的 Isolate。\n\n`src/node.cc`\n```\ninline int Start(Isolate* isolate, IsolateData* isolate_data,\n                 int argc, const char* const* argv,\n                 int exec_argc, const char* const* exec_argv) {\n//...\n    {\n    SealHandleScope seal(isolate);\n    bool more;\n    PERFORMANCE_MARK(&env, LOOP_START);\n    do {\n      uv_run(env.event_loop(), UV_RUN_DEFAULT);\n\n      v8_platform.DrainVMTasks(isolate);\n\n      more = uv_loop_alive(env.event_loop());\n      if (more)\n        continue;\n\n      EmitBeforeExit(&env);\n\n      // Emit `beforeExit` if the loop became alive either after emitting\n      // event, or after running some callbacks.\n      more = uv_loop_alive(env.event_loop());\n    } while (more == true);\n    PERFORMANCE_MARK(&env, LOOP_EXIT);\n  }\n//...\n}\n```\n\n`deps/uv/src/unix/core.c`\n```\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r)\n    uv__update_time(loop);\n\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    uv__run_timers(loop);\n    ran_pending = uv__run_pending(loop);\n    uv__run_idle(loop);\n    uv__run_prepare(loop);\n\n    timeout = 0;\n    if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout);\n    uv__run_check(loop);\n    uv__run_closing_handles(loop);\n\n    if (mode == UV_RUN_ONCE) {\n      /* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I/O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n       * the check.\n       */\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n      break;\n  }\n\n  /* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   */\n  if (loop->stop_flag != 0)\n    loop->stop_flag = 0;\n\n  return r;\n}\n```\n\n`deps/uv/src/unix/core.c`\n```\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n```\n\n`deps/uv/src/unix/linux-core.c`\n```\nvoid uv__io_poll(uv_loop_t* loop, int timeout) {\n  while (!QUEUE_EMPTY(&loop->watcher_queue)) {\n    q = QUEUE_HEAD(&loop->watcher_queue);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n\n    w = QUEUE_DATA(q, uv__io_t, watcher_queue);\n   \n    e.events = w->pevents;\n    e.data = w->fd;\n\n    if (w->events == 0)\n      op = UV__EPOLL_CTL_ADD;\n    else\n      op = UV__EPOLL_CTL_MOD;\n\n    /* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching\n     * events, skip the syscall and squelch the events after epoll_wait().\n     */\n    if (uv__epoll_ctl(loop->backend_fd, op, w->fd, &e)) {\n      if (errno != EEXIST)\n        abort();\n\n      assert(op == UV__EPOLL_CTL_ADD);\n\n      /* We've reactivated a file descriptor that's been watched before. */\n      if (uv__epoll_ctl(loop->backend_fd, UV__EPOLL_CTL_MOD, w->fd, &e))\n        abort();\n    }\n\n    w->events = w->pevents;\n  }\n  \n  \n}\n```\n\n### 异同\n表现形式一样\n\n实现不一样\n\nnode中事件循环依靠libuv引擎，多个队列，没有微任务和宏任务的划分。\n### 参考文献\n\nhttps://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick\n\nhttps://yjhjstz.gitbooks.io/deep-into-node/chapter2/chapter2-0.html\n","tags":["nodejs"]},{"title":"Nodejs之web服务基础","url":"/2018/05/15/nodejs-server-base/","content":"\n### 规划\n+ 服务器开发基础\n+ 搭建一个简单的服务器\n+ koa框架运行原理\n+ 服务器线上运行保障\n\n### 协议模型\n#### 分层\n\n理论上的网络协议分为7层（OSI），目前实际上是用的是tcp/ip 5层协议。\n\n各层的职责：\n\n物理层：确保数据在物理媒介上进行传输，主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。\n\n链路层：定义数据帧，确定主机的物理地址（MAC地址），以太网协议。\n\n网络层：负责传输过程中路由的选择，找到目标的网络地址，实现主机到主机的传输，IP协议。\n\n传输层：负责端到端的传输，对于多个使用网络的进程通过端口进行区分，TCP/UDP协议。\n\n应用层：定义数据的格式，并按照对应的格式封包解包，HTTP协议。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB4bf9b80aeb81ea1a4cdf8bc7f48fb146?method=download&shareKey=f84c786ef44bb3d96ad5ec2511d37bbf)\n\n用户通过http发起请求的时候，应用层，传输层，网络层，链路层都会根据相关协议添加对应的首部，最终在数据链路层形成以太网数据包。然后通过物理层进行传输，到达对方主机后，再通过一层层解包还原传过来的数据包。\n\n#### tcp连接的建立\n\ntcp连接的建立要经历三次握手，以确保建立可靠连接，如下图所示：\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB3ecdd4743c6e92b3a6384254db7af6af?method=download&shareKey=8266dbec154736773df1f2409081580b)\n\n(1) 第一次握手，Client发送SYN包到Server，告诉Server，本次消息的序列号为J\n\n(2) 第二次握手，Server回复SYN + ACK包给Client，期待下次Client发送消息的序列号位J+1，并告诉Client，本次消息的序列号为K\n\n(3) 第三次握手，Client回复ACK给Server，期待下次Server发送消息的序列号位K+1\n\n#### tcp vs udp\n协议|连接性|双工性|可靠性|有序性|有界性|拥塞控制|传输速度|头部大小\n---|---|---|---|---|---|---|---|---\nTCP|面向连接|全双工|可靠(重传机制)|有序(通过SYN排序)|无, 有粘包情况|有|慢|20~60字节\nUDP|无连接|n:m|不可靠(丢包后数据丢失)|无序|有消息边界, 无粘包|无|快|8字节\n\n常见应用场景\n\n<table>\n  <tr><th>传输层协议</th><th>应用</th><th>应用层协议</th></tr>\n  <tr><td rowspan=\"5\">TCP</td><td>电子邮件</td><td>SMTP</td></tr>\n  <tr><td>终端连接</td><td>TELNET</td></tr>\n  <tr><td>终端连接</td><td>SSH</td></tr>\n  <tr><td>万维网</td><td>HTTP</td></tr>\n  <tr><td>文件传输</td><td>FTP</td></tr>\n  <tr><td rowspan=\"8\">UDP</td><td>域名解析</td><td>DNS</td></tr>\n  <tr><td>简单文件传输</td><td>TFTP</td></tr>\n  <tr><td>网络时间校对</td><td>NTP</td></tr>\n  <tr><td>网络文件系统</td><td>NFS</td></tr>\n  <tr><td>路由选择</td><td>RIP</td></tr>\n  <tr><td>IP电话</td><td>-</td></tr>\n  <tr><td>流式多媒体通信</td><td>-</td></tr>\n</table>\n\n简单的说, UDP 速度快, 开销低, 不用封包/拆包允许丢一部分数据, 监控统计/日志数据上报/流媒体通信等场景都可以用 UDP. 目前 Node.js 的项目中使用 UDP 比较流行的是 [StatsD](https://github.com/etsy/statsd) 监控服务.\n\n#### http协议\n\n默认使用80端口\n\n1991年的0.9版 -> 1996年的1.0版 -> 1997年的1.1版(目前主流版本)\n\n支持的方法：\n\nGET（0.9）\n\nPOST\nHEAD（1.0新增）\n\nPUT\nPATCH\nOPTIONS\nDELETE（1.1新增）\n\n+ 请求格式：\n```\nGET / HTTP/1.1\nHost: localhost:8009\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7\n```\n第一行为请求方法和协议版本\n\nConnection表示维持连接，不必要重新建立TCP连接。\n\nUser-Agent为浏览器的信息\n\nAccept代表客户端可以接受的数据格式\n\nAccept-Encoding代表客户端接受的压缩方式\n\n+ 响应格式：\n\n```\nHTTP/1.1 200 OK\nAccept-Ranges: bytes\ncontent-type: text/html; charset=utf-8\ncontent-length: 51807\nkeep-alive: timeout=5\nDate: Mon, 09 Apr 2018 12:29:46 GMT\nConnection: keep-alive\n\n!DOCTYPE html> <html> <head> <meta charset=utf-8>\n```\n\n回应格式是“头信息 + 空行 + 数据”，其中第一行是协议版本，状态码，状态描述\n\ncontent-type是告诉客户端，数据的格式是什么样的，以及数据所采用的编码。对应请求是的Accept\n\ncontent-length为当前传输数据的字节数。由于一个TCP连接可以传送多个回应，所以需要区分数据包属于哪一个回应，这就是content-length的作用。\n\ncontent-encoding代表当前采用的压缩方式。\n\n+ x-www-form-urlencoded与multipart/form-data的区别\n\n\"application/x-www-form-urlencoded\"，他是默认的MIME内容编码类型，一般可以用于所有的情况。但是他在传输比较大的二进制或者文本数据时效率极低。这种情况应该使用\"multipart/form-data\"。如上传文件或者二进制数据和非ASCII数据。\n\n关于\"application/x-www-form-urlencoded\"和\"multipart/form-data\"的消息的区别可以看下面的例子：\n这是一个表单，有2个表单域：name和email\n```\n -------------------------------------\n| field     value                                           |\n| name:  ryan ou                                       |\n| email:  ryan@rhythmtechnology.com      |\n--------------------------------------\n```\n \n在 application/x-www-form-urlencoded 消息中:\nname=ryan+ou&email=ryan@rhythmtechnology.com\n(不同的field会用\"&\"符号连接;空格被替换成\"+\";field和value间用\"=\"联系,等等)\n \n \n再看multipart/form-data 消息中:\n```\n......\n-----------------------------7cd1d6371ec\nContent-Disposition: form-data; name=\"name\"\n \nryan ou\n-----------------------------7cd1d6371ec\nContent-Disposition: form-data; name=\"email\"\n \nryan@rhythmtechnology.com\n-----------------------------7cd1d6371ec\nContent-Disposition: form-data; name=\"Logo\"; filename=\"D:\\My Documents\\My Pictures\\Logo.jpg\"\nContent-Type: image/jpeg\n ......\n ```\n(每个field被分成小部分，而且包含一个value是\"form-data\"的\"Content-Disposition\"的头部；一个\"name\"属性对应field的ID,等等)\n\n当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&name2=value2...），然后把这个字串append到url后面，用?分割，加载这个新的url。\n\n当action为post时候，浏览器把form数据封装到http body中，然后发送到server。\n\n如果没有 type=file 的控件，用默认的 application/x-www-form-urlencoded 就可以了。\n\n但是如果有 type=file 的话，就要用到 multipart/form-data 了。浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file)、Content-Type(默认为text/plain)、name(控件name)等信息，并加上分割符(boundary)。\n\n#### 一次http请求过程\n\n打开地址栏，输入www.163.com，这意味着浏览器要想163发起一个网络请求。\n\n发送数据包的时候，必须要知道对方的ip地址，这里我们只知道域名，所以要通过dns协议对域名进行解析，OS会向DNS服务器查询，然后DNS服务器返回163的IP地址为61.149.22.99\n\n得到目标主机的IP后，需要通过子网掩码来判断目标主机是不是在同一网段，通过判断，目标主机不在同一网段，需要通过网关进行转发。\n\n请求的HTTP内容如下：\n\n```\nGET  HTTP/1.1\nHost: www.163.com\n```\n\n上面HTTP的数据会封装在TCP包里面，TCP设置好远程端口80，和本地端口（随机分配）\n\n然后TCP数据包封装在IP数据包中，IP包中填入双方的IP地址，自己的IP地址为10.235.18.95，远程的IP地址为通过dns查询得到的61.149.22.99。\n\n最后TCP数据要封装在以太网数据包中，以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关10.235.0.1的MAC地址（通过ARP协议得到）\n\n经过多个网关的转发，163服务收到以太网的数据包，按照封包的逆顺序进行拆包，得到HTTP的数据，然后封装好HTTP的响应数据，发送给我们，浏览器收到服务器返回的数据后，直接展示出来，这样就完成了一次网络通信。\n\n### Node相关\n\n+ Node的前世今生\n\nNode.js 诞生于 2009 年，由 Joyent 的员工 Ryan Dahl 开发而成，2015年Node基金会的成立，并发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会稳定的发布5、6、7、8、9等版本，截止到目前(2018.4.10)最新版本已经是9.11.1，长期支持版本是8.11.1。\n\n+ Node是什么\n\n>Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n\n\nNode.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境。Node.js使用事件驱动、非阻塞I/O模型。Node.js的包管理器npm是全球最大的开源库生态系统。\n\nNode.js结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。\n\n+ Node中的事件\n\n```\nconst EventEmitter = require('events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('触发了一个事件！');\n});\nmyEmitter.on('another event', (data) => {\n    console.log('触发了另一个事件！', data);\n  });\nmyEmitter.emit('event');\n\nsetTimeout(()=>{\n    myEmitter.emit('another event','msg');\n},2000);\n```\n\n+ Node的框架\n\nNode.js可分为四大部分：Node Standard Library（Native modules），Node Binding（builtin modules），V8，libuv\n\n![image](https://yjhjstz.gitbooks.io/deep-into-node/chapter1/a9e67142615f49863438cc0086b594e48984d1c9.jpeg)\n\nNode Standard Library用JS编写，供我们应用程序进行调用（Http模块），平时经常接触到的就是这部分库了。\n\nNode Binding使用C\\+\\+编写，是连接JS和C\\+\\+的桥梁，封装了libuv和V8的细节，为上层标准库提供接口。\n\nV8提供JavaScript的运行环境，执行我们的JS代码，可以认为是Node的发动机。\n\nlibuv重写了JS中的事件驱动，提供异步I/O模型，提供跨平台的支持。\n\n### 总结\n+ 互联网协议的构成\n+ TCP连接建立过程\n+ HTTP协议\n+ 一次完整的HTTP请求\n+ Node介绍\n\n### 参考\nhttp://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html\nhttps://www.cnblogs.com/onepixel/p/7092302.html\n","tags":["nodejs"]},{"title":"Nodejs之web服务开发","url":"/2018/05/15/nodejs-server-web/","content":"\n### 内容大纲\n+ 原生http\n+ connect\n+ koa\n\n### 原生http\n\n#### http模块的组成\nnode里面内置了http的模块，http模块中四个很重要的类会经常用到，分别是`http.Server`,`http.ClientRequest`,`http.ServerResponse`,`http.IncomingMessage`，下图反应了他们之间的关系。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB038b0dbdf13606320ea6a08cde1d3bb5?method=download&shareKey=7888dd66e68cafbae317d29777063ecd)\n\n#### 简单的http服务器\n一个简单的http服务端实现是这样:\n```\n//demo1.js\nconst http = require('http');\nlet num = 0;\nhttp.createServer((request,response)=>{\n    console.log('new request ! ',++num);\n    response.end('Hello World');\n}).listen(8080);\nconsole.log('now listen on 8080');\n```\n`createServer`方法会返回一个`http.Server`的实例，创建的时候可以传入一个`requestListener`，该函数会自动绑定到 `request`事件上，当客户端向服务器端发起请求的时候，就会触发`request`事件，`request`事件的回调函数有两个参数，第一个参数是`http.IncomingMessage`，第二个参数是`http.ServerResponse`，`http.IncomingMessage`代表`client`端的信息，比如httpVersion，headers，method等。`http.ServerResponse`包含服务端一些列数据处理方法，比如设置头信息，往sokcet中写入数据等。\n\n#### 文件的传输\n\nnode中提供了`Stream类`，结合`http.SeverResponse`类，可以很方便的将文件流接入到socket流里面。如果服务端不设置编码类型，默认为chunked，这是由node异步机制决定的，下面是传输图片的例子。\n\n```\n//server.js\nconst http = require('http');\nlet num = 0;\nhttp.createServer((req,res)=>{\n    console.log('new request ! ',++num);\n    res.writeHead(200,{'Content-Type':'image/jpeg'});\n    require('fs').createReadStream('desert.jpeg').pipe(res);\n}).listen(8080);\nconsole.log('now listen on 8080');\n```\n#### 主动发起请求\nNode中，可以通过`http.request`或者`http.get`主动发起请求，这两个函数均返回一个`http.ClientRequest`的实例。发起请求的时候，可以传入一个回调函数，该回调函数会绑定在`response`事件上，当请求相应被接收到的时候触发该事件，回调函数的参数为`http.IncomingMessage`的实例。\n\n```\n//client.js\nhttp.get('http://127.0.0.1:8080',(res)=>{\n\tlet num = 0;\n    res.on('data',(data)=>{\n\t\tconsole.log('******chunk data******\\r\\n');\n\t\tconsole.log(`chunk: ${++num}  len: ${data.length}\\n`);\n    });\n    res.on('end',()=>{\n\t\tconsole.log('******responese end******\\r\\n');\n    });\n});\n```\n\n#### 获取client数据\n编写服务器的时候，针对客户端不同的请求路径，需要展示不同的页面，这个过程称为路由，请求路径通过`http.IncomingMessage`实例的url可以拿到，`http.IncomingMessage`实现了可读流的接口，通过流的`data`事件和`end`事件，能够获取来自client端提交过来的数据。\n\n```\nconst http = require('http');\nconst qs=require('querystring');\n\nlet num = 0;\nhttp.createServer((req,res)=>{\n    console.log('new request ! ',++num);\n    res.writeHead(200,{'Content-Type':'text/html; charset=utf-8'});\n    if(req.url === '/register' && req.method === 'POST') {\n        let content = '';\n        req.on('data',(chunk)=>{\n            content += chunk;\n        });\n        req.on('end',()=>{\n            let param = qs.parse(content);\n            param = JSON.stringify(param);\n            res.end(`<p>Content-Type: ${req.headers['content-type']}</p><p>Data: ${param}</p>`,'utf-8');\n        });\n    } else if('/' === req.url){\n        res.end([\n                '<form method=\"POST\" action=\"/register\">',\n                '<h1>表单</h1>',\n                '<fieldset>',\n                '<label>个人信息</label>',\n                '<p>姓名: <input type=\"text\" name=\"name\"/> </p>',\n                '<p><button>提交</button></p>',\n                '</form>'\n        ].join(''));\n    } else {\n        res.writeHead(404)\n        res.end('Not Found');\n    }\n}).listen(8080);\nconsole.log('now listen on 8080');\n```\n服务端在writeHead的时候需要指定charset，不然客户端会显示为乱码，res.write()和res.end()的时候默认编码是utf-8。\n\n#### 辅助工具\n调试服务器的时候，可能会需要经常改动服务端代码，停掉服务器，然后重启服务器，这一个过程会非常麻烦，这时候可以使用第三方的工具`nodemon`，`nodemon`会监视文件的变化，然后自动重启服务器。\n```\nnpm i nodemon --save-dev\n```\nnodemon的配置\n```\n//package.json\n\n  \"nodemonConfig\": {\n    \"ignore\": [\"test/*\", \"docs/*\", \"*.jpeg\"],\n    \"delay\": \"2500\"\n  }\n```\n\n#### 静态网站\n```\nconst http = require('http');\nconst fs = require('fs');\n\nfunction notfound(res) {\n    res.writeHead(404);\n    res.end('Not Found');\n}\n\nfunction show(path, type, res) {\n    fs.stat(path, (err, stat) => {\n        if (err || !stat.isFile()) {\n            notfound(res);\n        } else {\n            res.writeHead(200, {\n                'Content-Type': type\n            });\n            fs.createReadStream(path).pipe(res);\n        }\n    });\n}\nconst STATIC_PATH = '/public'\nconst server = http.createServer((req, res) => {\n    console.log('url: ', req.url);\n    if (req.url.startsWith('/image')) {\n        let suffixIndex = req.url.lastIndexOf('.');\n        if (suffixIndex > 0) {\n            let suffix = req.url.substring(suffixIndex + 1)\n            show(__dirname + STATIC_PATH + req.url, 'image/' + suffix, res);\n        } else {\n            notfound(res);\n        }\n    } else if (req.url === '/') {\n        show(__dirname + STATIC_PATH + '/index.htm','text/html', res);\n    } else {\n        notfound(res);\n    }\n});\nserver.listen(8080);\nserver.on('error',(err)=>{\n    console.log(err);\n});\n```\nError: listen EACCES 0.0.0.0:80\n\n原因监听 1024 以下端口 需要sudo权限，否则报   listen EACCES 错误\n\n### connect\n\n#### http服务器\n```\nconst http = require('http');\nconst connect = require('connect');\nconst app = connect();\napp.use((req,res,next)=>{\n    res.end('Hello from connect\\r\\n');\n});\napp.listen(8080);\n```\n#### 静态资源服务器\n\n```\nconst http = require('http');\nconst connect = require('connect');\nconst app = connect();\nconst serveStatic = require('serve-static');\napp.use(serveStatic('public',{'index':['index.html','index.htm']}));\napp.listen(8080);\n\n```\n\n#### connect中间件\n\n```\nconst http = require('http');\nconst connect = require('connect');\nconst responseTime = require('response-time');\nconst app = connect();\n\napp.use(responseTime());\napp.use((req,res,next)=>{\n    console.log('111');\n    next();\n    console.log('222');\n});\napp.use('/api',(req,res,next)=>{\n    console.log('333');\n    res.write('before next\\n');\n    next();\n    res.end('hello api');\n    console.log('444');\n});\napp.use((req,res,next)=>{\n    console.log('555');\n    next();\n    console.log('666');\n});\napp.use((req,res,next)=>{\n    res.write('common info\\n');\n    res.end('end');\n});\napp.listen(8080);\nconsole.log('server start at port: ', 8080);\n```\n\n#### connect中的错误处理\n```\nconst http = require('http');\nconst connect = require('connect');\nconst app = connect();\n\napp.use((req,res,next)=>{\n    setTimeout(()=>{\n        console.log('async');\n        throw(new Error('Async Error Demo'));\n    },1000);\n    throw(new Error('Error Demo'));\n    next();\n});\n\napp.use((req,res,next)=>{\n    console.log('middware');\n    next();\n});\n\napp.use((err,req,res,next)=>{\n    console.log(\"err1:\",err);\n    res.end('err1');\n    // next(err);\n});\napp.use((err,req,res,next)=>{\n    console.log(\"err2:\",err);\n    res.statusCode = 500;\n    res.end('Internal Error');\n});\napp.listen(8080);\nconsole.log('server start at port: ', 8080);\n```\n原则:\n+ 通过特殊的中间件进行处理，参数为4个，第一个为错误信息\n+ 出错后，寻找最近的一个错误中间件进行处理\n+ 可以通过next(err)传递到下一个错误中间件\n+ 对于异步抛出的错误，需要在异步中调用next(err)来抛出错误。\n\n#### callback hell\n```\napp.use((req,res,next)=>{\n    console.log('111');\n    proxy.fetchUser((err, data)=>{\n        if(!err){\n            console.log('user fetched!');\n            res.write(JSON.stringify(data));\n            res.write('\\n');\n            proxy.fetchInfo((err,data)=>{\n                if(!err){\n                    console.log('info fetched');\n                    res.write(JSON.stringify(data));\n                    res.write('\\n');\n                }\n                next();\n            });\n        } else {\n            //error \n            next();\n        }\n    });\n    console.log('222');\n});\n```\nexpress是对connect的封装，驱动方式一样，内置了很多组件，比如router，logger等，还有很多第三方组件方便开发者使用。express还支持使用模板渲染网页。express的使用可以参考https://github.com/expressjs/express。\n\n#### 通过模板渲染页面\n\n```\n//index.ejs\n\n<h1>express demo</h1>\n<p>输入你的名字</p>\n<form action=\"/register\" method=\"POST\">\n    <input type=\"text\" name=name>\n    <button>提交</button>\n</form>\n\n//normal.ejs\n\n<h1>欢迎</h1>\n<b><%= name %></b>\n```\n\n#### express服务器\n```\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser')\napp.set('view engine', 'ejs');\napp.set('views', __dirname + '/views');\napp.set('view options', {\n    layout: false\n})\napp.use(bodyParser.urlencoded({\n    extended: true\n}));\n\napp.get('/', (req, res) => {\n    res.render('index');\n});\n\napp.post('/register', (req, res, next) => {\n    res.render('normal', {\n        name: req.body.name\n    });\n})\n\napp.get('/api/check', (req, res) => {\n    res.json({\n        retcode: 200,\n        retdesc: 'success'\n    });\n});\napp.use((err, req, res, next) => {\n    console.log(err);\n});\napp.listen(8080);\n```\n\n### koa\nkoa是和connect类似的框架，koa使用async、await消除了深层的callback，可以用同步的方式去写异步的代码，koa的理念和express不同，koa只提供必要的组件，核心框架很简洁，没有内置其他的组件，我们在实现某个功能的时候，可以根据自己的需要去选择喜欢的第三方组件，koa支持的第三方组件可以上[wiki](https://github.com/koajs/koa/wiki)上查询。\n\n#### koa的例子\n\n```\nconst koa = require('koa');\nconst staticServer = require('koa-static');\nconst logger = require('koa-logger');\nconst koaRouter = require('koa-router');\nconst bodyParser = require('koa-bodyparser');\n\nconst app = new koa();\n\napp.use(async(ctx,next)=>{\n    console.log('koa---1');\n    await next();\n    console.log('koa---2');\n})\n\napp.use(bodyParser());\n\napp.use(logger());\n\nconst router = new koaRouter();\nconst apiRoute = require('./routes/api');\nrouter.use('/api',apiRoute.routes());\napp.use(router.routes()).use(router.allowedMethods());\n//跳转\nrouter.get('/redirect',async(ctx,next)=>{\n    ctx.response.redirect('/');\n    ctx.body = 'Main Page';\n});\napp.use(staticServer(__dirname + '/public'));\n\napp.listen(8080);\n```\n对ctx.body赋值就是将数据返回给客户端，可以通过ctx.redirect()来实现302跳转，设置ctx.status可以对http的status code进行设置，如果没有对ctx.body进行赋值，则ctx.status默认为404，如果已经对ctx.body赋值，则ctx.status值为200。\n\n#### koa中的错误处理\n得益于koa的框架，捕获服务器的错误变得非常方便，只需要加入一个`try catch`的代码块将`next()`函数包裹起来就可以了。\n\n```\nconst koa = require('koa');\nconst app = new koa();\napp.use(async (ctx, next) => {\n    try {\n        await next();\n    } catch (err) {\n        console.log('error handler', err);\n    }\n});\n\napp.use(async (ctx, next) => {\n    console.log('koa---1');\n    await next();\n    console.log('koa---2');\n})\n\napp.use(async (ctx, next) => {\n    console.log('koa---3');\n    // throw new Error('error3');\n    await next();\n    console.log('koa---4');\n    // throw new Error('error4');\n})\n\napp.use(async (ctx, next) => {\n    console.log('koa---5');\n    await next();\n    console.log('koa---6');\n})\napp.use(async (ctx,next) =>{\n   ctx.body = 'ok' ;\n});\napp.listen(8080);\n```\n在error3和error4的位置抛出异常都能够被错误处理中间件捕获，和connect类似，当错误抛出的时候，koa不在执行其他的中间件，直接跳到错误处理中间件处理错误。\n\n通过`try catch`捕获的错误不会触发app的error事件，如果需要在`app.on('error')`中继续处理该错误，可以通过`ctx.app.emit('error',err)`来释放该error事件。\n\n### 服务器的一般目录结构\n```\n├── logs\n├── package.json\n├── public\n│   ├── index.html\n│   └── news.html\n├── server\n│   ├── app.js\n│   ├── config\n│   ├── controller\n│   ├── routes\n│   └── service\n└── views\n    ├── index.ejs\n    └── welcome.ejs\n```\nlogs为输入日志的目录，public为静态文件目录，线上环境下一般放在cdn上，然后通过nginx进行转发，view为模板目录，config为服务器配置目录，一般服务器都会分好几个环境，比如dev，test，online环境。service为各种服务的抽象，一般用来做业务逻辑的封装，减轻controller层的任务，保证业务逻辑的独立性，提供给不同controller调用。controller层负责解析用户的数据，并请求相应的service获取数据，拼接成用户所需要的数据返回给用户。routes里面对路由进行设置，不同的请求路径调用不同的controller。\n\n### 课后作业\n#### 目标\n实现一个版本管理后台\n\n#### 需求\n+ 提供版本录入功能\n    + 包含当前版本号，系统(Android/IOS/RN)，环境(dev/online)，是否强制更新，灰度级别(1%,10%,30%,50%,100%)\n+ 修改灰度级别\n+ 上线，下架功能\n+ 获取最新版本信息(传入系统环境参数)\n+ 额外\n    + 白名单(保证每次都会灰度)\n    + 白名单的管理(增删改查)\n","tags":["nodejs"]},{"title":"Webpack3.0","url":"/2017/11/14/webpack-v3/","content":"\n## 主要特性\n* 依赖解析, 打包合并\n* 支持异步模块, 按需加载\n* 预编译代码, 通过loaders处理es6, jsx, less, sass等格式的模块\n* 多任务处理, 通过plugins提供代码混淆、压缩、样式提取等功能\n* 支持 ES6 & commonJS 模块\n* 支持 sourcemap\n\n## 主要流程\nwebpack构建时, 从入口文件开始, 循环的解析依赖, 并将项目所需要的依赖, 打包成一个或多个文件输出\n\n生成compiler -> 处理入口模块 -> 解析模块依赖 -> 调用loader加载模块 -> 打包文件, 拆分异步chunks -> 调用插件处理文件内容 -> 输出模块文件\n\n## 核心概念\n* 入口文件 (Entry) 构建项目和解析依赖关系的入口\n* 输出文件 (Output) 打包后文件的输出格式和位置\n* 加载器 (Loaders) 针对不同格式模块的预处理器, 可以替换或转义代码内容\n* 插件 (Plugins) 代码打包输出前的最后处理, 如压缩和混淆等操作\n\n### Entry\n**单一入口, entry: string | Array <string>**\n```\nconst config = {\n  entry: './path/to/my/entry/file.js'\n}\n```\n**多个入口,  entry: {[entryChunkName: string]: string | Array<string>}**\n```\nconst config = {\n  entry: {\n    vendor: './path/to/my/entry/file1.js',\n    index: ['./path/to/my/entry/file2.js', './path/to/my/entry/app.js']\n  }\n}\n```\n\n### Output\n输出配置至少需要以下两个配置\n* filename, 输出文件的名称(格式)\n* path, 输出文件夹的绝对路径\n\n```\nconst config = {\n  output: {\n    filename: 'bundle.js',\n    path: '/home/proj/public/assets'\n  }\n}\n```\n额外的属性\n* chunkFilename, 拆分bundle文件的名称(格式)\n* publicPath, 静态资源的线上路径\n\n```\nconst config = {\n  output: {\n    path: '/home/proj/build',\n    publicPath: '/cdn/'\n    filename: '[name].[chunkhash:8].js',\n    chunkFilename: 'chunk.[name].[chunkhash:8].js',\n  }\n}\n```\n**常用的名称格式有以下几种**\n\n| 标记 | 描述 |\n| --- | --- |\n| [hash] | 模块id的hash值 |\n| [chunkhash] | chunk内容的hash值 |\n| [name] | 模块的名称 |\n| [id] | 模块的id |\n\n### Loader\n必要的属性\n* test, 正在表达式, 用于匹配文件名\n* loader/use, 处理文件内容的加载器\n\n额外的属性\n* include, 指定文件的目录范围\n* exclude, 指定排除的目录\n* options/query, 加载器的参数配置\n\n\n```\nmodule: {\n  rules: [{\n    test: /\\.jsx?$/,\n    loader: 'babel-loader',\n    exclude: [\n      path.resolve(SRC_PATH, '../node_modules')\n    ]\n  }, {\n    test: /\\.css?$/,\n    use: ['style-loader', 'css-loader', 'postcss-loader']\n  }]\n}\n```\n### Plugin\n提供定制化的webpack编译模式, 下面是一些常用插件\n```\nplugins: [\n  // build optimization plugins\n  new webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    filename: 'vendor-[hash].min.js',\n  }),\n  new webpack.optimize.UglifyJsPlugin({\n    compress: {\n      warnings: false,\n      drop_console: false,\n    }\n  }),\n  new ExtractTextPlugin({\n    filename: 'index.min.css'\n  }),\n  new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/),\n  // compile time plugins\n  new webpack.DefinePlugin({\n    'process.env.NODE_ENV': '\"production\"',\n  }),\n  // webpack-dev-server enhancement plugins\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n## 升级 3.0\n此次从1.0升级到3.0, 带来了许多新的功能点\n\n* 支持ES6模块, 如import, export等语法(v2)\n* 针对ES6模块, 提供动态加载方法`import()`(v2), 并通过注释定义模块信息(v3)\n* 基于ES6模块的静态结构, 提供Tree shaking功能, 移除未被使用的模块输出(v2)\n* 作用域提升/合并, 通过启用插件`webpack.optimize.ModuleConcatenationPlugin`, 减少模块打包后产生的闭包数量, 优化代码执行速度和打包体积(v3)\n* 集成常用loader, 如less, sass, CoffeeScript, TypeScript等\n\n## 迁移至新版本\n[webpack官方文档](https://doc.webpack-china.org/guides/migrating/#resolve-root-resolve-fallback-resolve-modulesdirectories)\n* resolve.modulesDirectories 改为 resolve.modules, 取消resolve.root\n* module.loaders 改为 module.rules, 并取消加载器自动添加'-loader后缀'\n* json-loader 不再需要手动添加, 已自动集成\n* loader 默认相对于 context 进行解析, 解决了引用 context 上下文目录之外的模块时，loader 所导致的模块重复载入的问题\n* UglifyJsPlugin 的默认配置 sourceMap & warnings 改为 false\n* loaders默认不再使用压缩模式, 可以通过插件`webpack.LoaderOptionsPlugin({minimize:true})`开启\n* 移除 webpack.optimize.DedupePlugin, 默认加载 webpack.optimize.OccurenceOrderPlugin\n* ExtractTextWebpackPlugin有较大改动, 具体内容请参考文档\n* require.ensure 以及 AMD require 将采用异步式调用, 而不是当 chunk 已经加载完成的时候同步调用它们的回调函数(callback)\n* 自定义属性配置loader无效, 只能通过options配置\n* debug模式, 需要通过loader的options配置\n* require.ensure & import() 两种方式实现动态加载模块, 可以混合使用ES2015、AMD 和 CommonJS模块, 但是每个模块内只能由一种模块格式\n* 让webpack处理ES6模块, 以启用tree shaking, 需要通过.babelrc或者babel-loader设置`modules:false`\n* 支持配置文件中返回Promise对象\n* 支持对loader更多方式的匹配\n","tags":["webpack"]},{"title":"JS对象继承","url":"/2017/08/11/javascript-object-inherit/","content":"\n## 构造函数\n\n**对象 B 继承对象 A：让对象 B 可以拥有对象 A 的属性和方法**\n\n+ 假设现有 Father 类，拥有属性 name, age\n+ 同时，Father 类原型有方法 getAge, sayHi\n\n```js\nfunction Father(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nFather.prototype.getAge = function() {\n    return this.age; \n}\n\nFather.prototype.sayHi = function() {\n    return `Hi ${this.name}`\n}\n```\n\n## Prototype\n\n**类的原型**\n\n```js\n类的 prototype 属性指向类原型对象\n类原型的 constructor 属性指向类自身\nA.prototype.constructor === A\n```\n![obj&it's prototype](https://attachments.tower.im/tower/1c24e97d5440461fb8c74714546c0741?filename=obj+and+its+prototype.png)\n\n实例可以拥有 prototype 对象里的属性和方法。\n\n```js\n// 变量 arr 继承了 Array 原型的 indexOf 方法\n// 变量 obj 继承了 Object 原型的 hasOwnProperty 方法\nlet arr = ['I', 'have', 'indexOf', 'method'];\nlet obj = {\n    msg: \"I'm object, I have hasOwnProperty method\"\n};\n\narr.indexOf('I')            // 0\nobj.hasOwnProperty('msg')   // true\nobj.hasOwnProperty('name')  // false\n```\n\n```js\nfunction ObjGenFunc(name) {\n    this.name = name;\n}\n// 类上的方法，不可以被实例继承\nObjGenFunc.saySorry = function() {\n    return 'sorry'\n}\n// 原型上的方法，可以被实例继承\nObjGenFunc.prototype.sayHi = function() {\n    return `hi ${this.name}!`;\n}\n// 原型上的属性，可以被实例继承\nObjGenFunc.prototype.age = 18;\n\nlet instance = new ObjGenFunc('asy');\ninstance.name;          // \"asy\"\ninstance.age;           // 18\ninstance.sayHi();       // \"hi asy!\"\ninstance.saySorry();    // error: instance.saySorry is not a function\n```\n\n![obj&it's inherit](https://attachments.tower.im/tower/f4f7314829c84127b5ed75ba93f9c3c7?filename=obj%26pro%26ins.png)\n\n**原型链**\n\nJS 实例对象有一个指向原型对象的指针(例如：浏览器显示的`__proto__`)。当访问一个对象的属性时：\n1. 先在该对象上搜寻，若找到则结束，若找不到进入第二步；\n2. 在该对象的`__proto__`指向的对象上继续寻找，找到则结束，找不到重复第二步；\n3. 依次层层向上搜索，直到找到一个匹配的属性，或者到达原型链的末尾(`Object.prototype.__proto__ === null`)\n\n当创建一个实例时:\n+ 实例对象的原型，用 `__proto__` 表示，指向其构造函数的 prototype 属性;\n+ 同时实例的 constructor 属性，指向其构造函数自身\n\n结合对象和其原型的关系，有以下关系和图示：\n\n```js\na.constructor === A\na.__proto__ === A.prototype\na.__proto__.constructor === A\n```\n\n**子类与父类**\n\n将子类的原型当做父类的实例来让子类原型继承父类的属性和方法，从而子类的实例能继承父类的实例和方法\n\n```js\nfunction Child(name, age, school) {\n    this.name = name;\n    this.age = age;\n    this.school = school;\n}\n\n// 将 Child 的原型视为父类 Father 的实例，因此 Child.prototype 就拥有了 Father 的原型方法和原型属性\nChild.prototype = new Father();\n// 继承链修正\nChild.prototype.constructor = Child;\n\nlet childIns = new Child('child', 18, 'RUC');\nchildIns.name/age/school;       // 'child' 18 'RUC'\nchildIns.sayHi();               // 'Hi child'\nchildIns.getAge();              // 18\n\nlet fatherIns = new Child('father', 50);\nchildIns.name/age;              // 'father' 50\nchildIns.sayHi();               // 'Hi father'\nchildIns.getAge();              // 50\n```\n\n```js\n// Father 和 Father 实例的关系\nfatherIns.constructor === Father\nfatherIns.__proto__ === Father.prototype\nfatherIns.__proto__.constructor === Father\n\n// Child 和 Child 实例的关系\nchildIns.constructor === Child\nchildIns.__proto__ === Child.prototype\nchildIns.__proto__.constructor === Child\n\n// Child 和 Father 的关系\nChild.prototype.__proto__ === Father.prototype\n```\n\n![prototype inherit](https://attachments.tower.im/tower/1301acd2c59e4f4abdff1333425be1f2?filename=ES5.png)\n\n## **ES6 继承**\n\n其实质是先创造父类的实例对象 this（也因此子类的 constructor 必须先调用 super 方法），然后再用子类的构造函数修改 this\n\n```js\n// 父类\nclass Father {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    _sayHi() {\n        return `Hi ${this.name}`\n    }\n    \n    _getAge() {\n        return this.age;\n    }\n}\n\n// 子类通过关键字 extends 实现对父类的继承\nclass Child extends Father {\n    constructor(name, age, school) {\n        super();\n        this.name = name;\n        this.age = age;\n        this.school = school;\n    }\n    \n    _getSchool() {\n        return this.school;\n    }\n}\n\nlet childIns = new Child('child', 18, 'RUC');\nchildIns.name/age/school;       // 'child', 18, 'RUC'\nchildIns._getSchool();          // 'RUC'\nchildIns._sayHi();              // 'Hi child'\nchildIns._getAge();             // 18\n\nlet fatherIns = new Father('father', 50);\nfatherIns._sayHi();             // 'Hi father'\nfatherIns._getAge();            // 50\n```\n\nES6 的继承语法更符合程序员以往接触的继承方式，并且 ES6 继承依然拥有 ES5 继承的特性：\n\n```js\n// Father 和 Father 实例的关系\nfatherIns.constructor === Father\nfatherIns.__proto__ === Father.prototype\nfatherIns.__proto__.constructor === Father\n\n// Child 和 Child 实例的关系\nchildIns.constructor === Child\nchildIns.__proto__ === Child.prototype\nchildIns.__proto__.constructor === Child\n\n// Child 和 Father 的关系\nChild.prototype.__proto__ === Father.prototype\n```\n\n此外，es6 继承，还有另一条继承链\n```js\nChild.__proto__ === Father\n```\n\n![ES6 inherit](https://attachments.tower.im/tower/0f82d45ff5424ccf9fc20127f03f557e?filename=inheritComp.png)\n\n**两条继承链**\n+ 原型链，子类原型的 `__proto__` 属性指向父类原型\n+ 类链，子类的 `__proto__` 属性直接指向了父类\n\n```js\nChild.prototype.__proto__ === Father.prototype\nChild.__proto__ === Father\n```\n```js\n// ES6 继承语法\nclass Child extends Father {}\n\n// 等同于\nObject.setPrototypeOf(Child.prototype, Father.prototype);\nObject.setPrototypeOf(Child, Father);\n```\n\nObject.setPrototypeOf 方法的作用与 `__proto__` 相同，用来设置一个对象的 prototype 对象\n```js\n// setPrototypeOf 方法实现\nObject.setPrototypeOf = function (obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n}\n```\n\n### 三类特殊的继承\n+ 继承 Object 类\n\n```js\nclass A extends Object {}\n\n// A 是构造函数 Object 的复制，A 的实例就是 Object 的实例\nA.__proto__ === Object;                      // true\nA.prototype.__proto__ === Object.prototype;  // true\n```\n\n+ 不继承：\n\n```js\nclass A {}\n\n// A 是普通函数，直接继承 Function.prototype\nA.__proto__ === Function.prototype;          // true\n// new A() 返回一个空对象, 所以 A.prototype.__proto__ 指向构造函数 Object 的 prototype 属性\nA.prototype.__proto__ === Object.prototype;  // true\n```\n\n+ 继承 null：\n\n```js\nclass A extends null {}\n\nA.__proto__ === Function.prototype;          // true\nA.prototype.__proto__ === undefined;         // true\n```\n\n### 补充1：Function & Object 的关系\n\n+ Function 和 Object 与其各自的原型的关系\n\n![origin](https://attachments.tower.im/tower/2fca4209d654444fb020cd31fc21a389?filename=of1.png)\n\n+ Object 和 Function 都是构造函数，而所有的构造函数的都是 Function 的实例对象，因此 Object 和 Function 都是 Function 的实例对象\n\n![Function.prototype](https://attachments.tower.im/tower/cc25fb9d30194547b44a3f3fab61634a?filename=of2.png)\n\n+ Function.prototype 是 Object 的实例对象\n\n![Object.prototype](https://attachments.tower.im/tower/321031acdc604c9c8219abf17e37525b?filename=of4.png)\n\n### 补充2：instanceof 运算符\n```js\nChild instanceof Function;   // true\nchildIns instanceof Child;   // true\nchildIns instanceof Father;  // true\nchildIns instanceof Object;  // true\n\n// ???\nObject instanceof Function;\nFunction instanceof Object;\n```\n\ninstanceof 运算符的实现\n\n```js\n// instance instanceof Class\nfunction instance_of(instance, Class) {\n    while (true) { \n        if (instance.__proto__ === null )\n            return false;\n        else if (instance.__proto__ === Class.prototype) \n            return true;\n\n        instance = instance.__proto__; \n            \n    }\n}\n```\n\n","tags":["javascript"]}]